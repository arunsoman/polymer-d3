
<link rel="import" href="../display-component/base-chart.html">
<dom-module id="box-plot">
  <template>
  <style>
    .box {
    font: 10px sans-serif;
    }
    .box line,
    .box rect,
    .box circle {
    stroke: #000;
    stroke-width: 1px;
    }
    .box .center {
    stroke-dasharray: 3,3;
    }
    .box .outlier {
    fill: none;
    stroke: #000;
    }
    .box text{
      fill:#000;
    }
    .axis {
    font: 12px sans-serif;
    }

    .axis path,
    .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
    }

    .x.axis path {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
    }
    svg {
      font: 29px sans-serif;
    }
    #chartContainer{
      margin:0 auto;
    }
    .legend rect{
      fill:transparent;
      stroke-width:0;
    }
  </style>
  <chart-input-group  uuid="[[uuid]]">
    <chart-input slot="chart-input" axis="x" label="Key"></chart-input>
    <chart-input slot="chart-input" axis="y" label="Value" accept="number"></chart-input>
  </chart-input-group>
  <chart-settings uuid="[[uuid]]"></chart-settings>
  <!-- <svg id="svg"></svg> -->
  <div id="chartContainer"></div>
</template>
<script>
  class boxPlot extends baseChart {
    static get is() {
      return 'box-plot'
    }
    static get properties() {
      return {
      }
    }
    constructor() {
      super();
    }
    redraw() {
      this.draw(this._paint(this._compute()));
    }
    _compute() {
      //axis are mentioned in the chart-input module
      let itemX = this.x ? this.inputs[this.x].selectedValue : []
      let itemY = this.y ? this.inputs[this.y].selectedValue : []

      //"itemChk" for avoid error from chart
      let itemChk = itemX.length <= 0 || itemY.length <= 0

      if (itemChk) {
          return false;
      }
      //axis inputs selectedValue assigin
      itemX = itemX[0]
      itemY=itemY[0]

      let labels = true,
          min = Infinity,
          max = -Infinity

      let width = this.settings.width.value,
          height = this.settings.height.value,
          margin = {top: 20, right: 20, bottom: 30, left: 40},
          label = this.settings.legend.values;
          //margin = {top: +this.settings.margin.value.top, right: +this.settings.margin.value.right, bottom: +this.settings.margin.value.bottom, left: +this.settings.margin.value.left}

      width = +width - margin.left - margin.right
      height = +height - margin.top - margin.bottom

      let color = d3.scale.category20c();

      //get chart data once pass "x and y" into the "getChartData" method

      let groupedData
      let source = this.getChartData(itemX, itemY)
      groupedData = d3.nest().key(d => d.item).entries(source);

      let chartData =[]
      groupedData.map((item,idx)=>{
        chartData[idx]=[item.key,item.values.map(test=>test.value)]
      })

      min = this.findMin(chartData)
      max = this.findMax(chartData)

      // debugger  // the x-axis
    	let x = d3.scale.ordinal()
    		.domain( chartData.map(d=> d[0]) )
    		.rangeRoundBands([0 , width], 0.7, 0.3);

    	let xAxis = d3.svg.axis()
    		.scale(x)
    		.orient("bottom");

    	// the y-axis
    	let y = d3.scale.linear()
    		.domain([min, max])
    		.range([height + margin.top, margin.top]);

    	let yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

      let chart = d3.box({y: y,formatNumber:this.formatNumber})
      		.whiskers(this.iqr(1.5))
      		.height(height)
      		.domain([min, max])
      		.showLabels(labels);

        width = width + margin.left + margin.right
        height = height + margin.top + margin.bottom

      return {
        width,
        height,
        color,
        x,
        xAxis,
        y,
        yAxis,
        chart,
        margin,
        itemChk,
        chartData,
        label
      }
    }

    _paint(obj) {
      d3.select(this.$.chartContainer).html("")
      if (!obj || obj.itemChk) {
        return false
      }
      this.chartKeys(obj,obj.chartData,0);
      let legendNodes = obj.chartData.map(items=>{return {key:items[0],color:obj.color(items[0])}});
      this.dispatch({type:'UPDATE_PRIVATE_NODE',value:{id:this.uuid,nodes:legendNodes}});

      let parentG = d3.select(this.$.chartContainer).append("svg")
        .attr("width", obj.width)
        .attr("height", obj.height+90)
        .attr("class", "box")
        .append("g")
        .attr("transform", "translate(" + obj.margin.left + "," + obj.margin.top + ")");

        // draw the boxplots
    	parentG.selectAll(".box")
        .data(obj.chartData)
    	  .enter().append("g")
    		.attr("transform", (d)=>"translate(" +  obj.x(d[0])  + "," + obj.margin.top + ")")
        .attr('class', 'box-g')
        .call(obj.chart.width(obj.x.rangeBand()))
        .attr('class', 'box')
        .attr("data-legend",function(d) { return d[0]})
        .style('fill', this.colorFill.bind(obj))
        .attr("data-legend-color",this.colorFill.bind(obj))

      // add a title
     parentG.append("text")
        .attr("x", (obj.width / 2))
        .attr("y", 0 + (obj.margin.top / 2))
        .attr("text-anchor", "middle")
        .text(this.settings.title.value);

    // draw y axis
   	parentG.append("g")
        .attr("class", "y axis")
        .call(obj.yAxis)
        .append("text") // and text1
          .attr("transform", "rotate(-90)")
          .attr("y", 14)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .style("font-size", "16px")

  	parentG.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + (obj.height+ 10) + ")")
        .call(obj.xAxis)
  	  .append("text")             // text label for the x axis
          .attr("x", (obj.width / 2) )
          .attr("y",  34 )
		      .attr("dy", ".71em")

    let legend = parentG.append("g")
      .attr("class","legend")
      .attr("transform","translate("+(obj.width*obj.label.position.x)/100+","+(obj.height*obj.label.position.y)/100+")")
      .call(d3.legend)

      d3.select(this.$.chartContainer).style({"width":obj.width+"px"})
    }
    // Returns a function to compute the interquartile range.
    iqr(k) {
      return function(d, i) {
        var q1 = d.quartiles[0],
            q3 = d.quartiles[2],
            iqr = (q3 - q1) * k,
            i = -1,
            j = d.length;
        while (d[++i] < q1 - iqr);
        while (d[--j] > q3 + iqr);
        return [i, j];
      }
    }
    // todo: format later
    formatNumber(d) {
      if (d < 1000) {
        return d;
      }
      d = d3.format('s')(d);
      let sufix = d.slice(-1);
      let num = parseFloat(d.slice(0, d.length)).toFixed(2);
      return  num + sufix;
    }
    // find maximum in an array of arrays
    findMax(arr) {
      return d3.max(arr, innerArray => d3.max(innerArray[1]));
    }
    // find minimum in an array of arrays
    findMin(arr) {
      return d3.min(arr, innerArray => d3.min(innerArray[1]));
    }
    // populate chart data
    getChartData(itemX, itemY){
        let sourcemap = this.source.map(row=>{
          return{[row[itemX]]:row[itemY]}
        })
        // debugger
        let source  = sourcemap.map(items=>{return {item:Object.keys(items)[0],value:items[Object.keys(items)[0]]}})
        return source
    }
  }
  customElements.define(boxPlot.is, boxPlot)
</script>
<script src="box.js"></script>
</dom-module>
