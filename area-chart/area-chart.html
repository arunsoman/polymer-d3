<link rel="import" href="../display-component/base-chart.html">
<dom-module id="area-chart">
  <template>
    <style>
    .axis path,
    .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
    }
    /*.x.axis path {
    display: none;
    }*/
    .area {
    fill: steelblue;
    }
    #chartContainer{
      margin:0 auto;
    }
    .legend-items text{
      fill:black
    }
    .legend{
      fill:transparent;
      font-size: 12px;
    }
    </style>
    <chart-input-group  uuid="[[uuid]]">
        <template is="dom-if" if="[[!stacked]]">
          <chart-input slot="chart-input" axis="x" label="Key" ></chart-input>
          <chart-input slot="chart-input" axis="y" label="Value" accept="number"></chart-input>
        </template>
        <template is="dom-if" if="[[stacked]]">
          <chart-input slot="chart-input" axis="x" label="Key"accept="number,date" ></chart-input>
          <chart-input slot="chart-input" axis="y" label="Value" accept="number"></chart-input>
          <chart-input slot="chart-input" axis="z" label="z-axis" accept="string"></chart-input>
        </template>
    </chart-input-group>
    <chart-settings uuid="[[uuid]]"></chart-settings>
    <!-- <svg id="svg"></svg> -->
    <div id="chartContainer"></div>
  </template>
  <script>
    class areaChart extends baseChart{
      static get is(){
        return "area-chart"
      }
      static get properties(){
        return{
          stacked:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let objAssignChk = (chartPath && chartPath.settings)
              return objAssignChk ?chartPath.settings.stacked.value:false
            }
          }
        }
      }
      constructor(){
        super()
      }
      redraw() {
        this.draw(this._paint(this._compute()));
      }
      _compute() {
        //assign stacked value
        let stacked = this.settings.stacked.value
        //axis are mentioned in the chart-input module
        let itemX = this.x ? this.inputs[this.x].selectedValue : []
        let itemY = this.y ? this.inputs[this.y].selectedValue : []

        //"itemChk" for avoid error from chart
        let itemChk = itemX.length <= 0 || itemY.length <= 0
        let itemZ = stacked && this.z ? this.inputs[this.z].selectedValue : []
        let itemStackChk = itemX.length <= 0 || itemY.length <= 0 || itemZ.length<=0
        itemChk = stacked ?itemStackChk: itemChk
        if (itemChk) {
            return false;
        }
        //axis inputs selectedValue assigin
        itemX = itemX[0]
        itemY=itemY[0]
        itemZ = itemZ[0]

        let formatDate = d3.time.format("%Y-%m-%d").parse;
        let width = +this.settings.width.value,
            height = +this.settings.height.value,
            margin = {top: 5, right: 40, bottom: 20, left: 120},
            label= this.settings.legend.values
            //margin = {top: +this.settings.margin.value.top, right: +this.settings.margin.value.right, bottom: +this.settings.margin.value.bottom, left: +this.settings.margin.value.left}
        width = width - margin.left - margin.right,
        height = height - margin.top - margin.bottom;

        let color = d3.scale.category20c();
        //get chart data once pass "x and y" into the "getChartData" method
        let source = this.getChartData(itemX, itemY,itemZ,stacked)
        let chartData,
            itemVal = source.itemVal&&source.itemVal
        if(stacked){
          color.domain(source.names);
          let stack = d3.layout.stack().values(function(d) { return d.values});
          chartData = stack(color.domain().map((name)=> {
                return {
                  name: name,
                  values: source.data.map((d)=> {
                    return {item: d.item, y: d[name] * 1};
                  })
                };
              }));
        }else{
          chartData = source.map((item,i)=>{
            itemVal = formatDate(item["item"].split(" ")[0])
            let itemSet = itemVal?itemVal:item["item"]
            return{"value":item.value,"item":itemSet}
          })
        }
        let srcData = stacked?source.data:chartData

        let dateX = d3.time.scale().range([0, width]);
        let stringX = d3.scale.ordinal().range([0, width]);

        let x = itemVal?dateX:stringX
        let y = d3.scale.linear().range([height, 0]);
        let xAxis = d3.svg.axis()
            .scale(x).orient("bottom");
        let yAxis = d3.svg.axis()
            .scale(y).orient("left");

        // Define area chart and set chart values and item
        let areaChart = d3.svg.area()
            .x((d)=>x(d.item))
            .y0((d)=>stacked?y(d.y0):height)
            .y1((d)=>stacked?y(d.y0 + d.y):y(d.value));

        // Set domains for X axes
        if(itemVal){
          x.domain(d3.extent(srcData, function(d) { return d.item; }));
        }else{
          x.domain(srcData.map(d=> d.item))
          .rangeRoundBands([0 , width]);
        }
        // Find the value of the item with highest total value
        let maxItemVal = d3.max(srcData, function(d){
          let vals = stacked && d3.keys(d).map(function(key){ return key !== "item" ? d[key] : 0 })
          return stacked?d3.sum(vals):d.value;
        });
        // Set domains for Y axes
        y.domain([0, maxItemVal]);
        let names = source.names
        return {
          width,
          height,
          margin,
          x,
          y,
          xAxis,
          yAxis,
          areaChart,
          itemChk,
          chartData,
          label,
          color,
          stacked,
          names
        }
      }
      _paint(obj) {
        d3.select(this.$.chartContainer).html("")
        if (!obj || obj.itemChk) {
          return false
        }
        let parentG = d3.select(this.$.chartContainer).append("svg")
            .attr({"width": obj.width + obj.margin.left + obj.margin.right,
                    "height": obj.height + obj.margin.top + obj.margin.bottom+40
            })
            .append("g")
              .attr("transform", "translate(" + obj.margin.left + "," + obj.margin.top + ")");

        if(obj.stacked){
          let chartSvg = parentG.selectAll("area-chart").data(obj.chartData)
            .enter().append("g")
            .attr("class", "area-chart")
          chartSvg.append("path")
              .attr("class", "area")
              .attr("d", function(d) {return obj.areaChart(d.values); })
              .style("fill", function(d) { return obj.color(d.name); });

          chartSvg.append("text")
              .datum(function(d) {return {name: d.name, value: d.values[d.values.length - 1]}; })
              .attr("transform", function(d) { return "translate(" + obj.x(d.value.item) + "," + obj.y(d.value.y0 + d.value.y / 2) + ")"; })
              .attr("x", -6)
              .attr("dy", ".35em")
              .text(function(d) { return d.name; });
        }else{
          parentG.append("path")
            .datum(obj.chartData)
            .attr({"class":"area",
                    "fill": "steelblue",
                    "d": obj.areaChart
                  })
        }
        parentG.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + obj.height + ")")
            .call(obj.xAxis);
        parentG.append("g")
            .attr("class", "y axis")
            .call(obj.yAxis)
            .append("text")
              .attr("transform", "rotate(-90)")
              .attr("y", 6)
              .attr("dy", ".71em")
              .style("text-anchor", "end")

        this.addLegend({
            obj,
            container:parentG,
            selector:'.area',
            node:obj.chartData
          });


        d3.select(this.$.chartContainer).style({"width":obj.width+ obj.margin.left + obj.margin.right+"px"})
      }
      // populate chart data
      getChartData(itemX, itemY,itemZ,stacked){
        let formatDate = d3.time.format("%Y-%m-%d").parse;
        if(stacked){
          let names=this.source.map(row=>row[itemZ])
          let itemVal
          let data = this.source.map((items,i)=>{
            itemVal = formatDate(String(items[itemX]).split(" ")[0])
            let itemSet = itemVal?itemVal:items[itemX]
            return this.source.reduce((old,newVal)=>{
              old[newVal[itemZ]]=items[itemZ]==newVal[itemZ] ? items[itemY]:newVal[itemY];
              return old},{item:itemSet})
            })
          return {data,names,itemVal}

        }else{
          let sourcemap = this.source.map(row=>{
            return{[row[itemX]]:row[itemY]}
          })
          let source  = sourcemap.map(items=>{return {item:Object.keys(items)[0],value:items[Object.keys(items)[0]]}})
          return source
        }
      }
    }
    customElements.define(areaChart.is,areaChart)
  </script>
</dom-module>
