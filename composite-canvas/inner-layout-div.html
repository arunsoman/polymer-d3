<link rel="import" href="../../iron-dropdown/iron-dropdown.html">
<link rel="import" href="../../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../iron-icons/iron-icons.html">
<link rel="import" href="../../paper-item/paper-item.html">
<!-- <link rel="import" href="../display-component/chart-holder.html"> -->
<link href="../behaviors/redux-mixins-behavior.html" rel='import'>
<link rel="import" href="recursive-elem.html">

<dom-module id="inner-layout-div">
  <template>
    <style>
      :host{
        min-height: 40vh;
      }
      header{
        border-bottom:1px #f6f6f6 solid;
      }
      #splitBox{
        position: relative;
      }
      #dropDown{
        margin-top:20px;
        border: 1px #e9e9e9 solid;
        background-color: white;
      }
      #dropDown paper-item{
        min-width: 49px;
        min-height: 16px;
        cursor: pointer;
        font: 10px sans-serif;
        border-bottom:none;
        padding: 2px 7px;
      }
      #dropDown paper-item+paper-item,
      #dropDown paper-item+dom-if+paper-item,
      #dropDown paper-item+dom-if+dom-if+paper-item{
        border-top: 1px #e9e9e9 solid;
      }
      .paperIconBtn, .addRemoveBtn{
        padding:5px;
        width: 25px;
        height: 25px;
        color: #939393
      }
      :host #splitter{
        display:none;
      }

    </style>
    <div id="splitBox">
      <header>
      <paper-icon-button icon="more-horiz" slot="dropdown-trigger" on-click="showDropDown" class="paperIconBtn">select</paper-icon-button>
      <iron-dropdown horizontal-align="left" vertical-align="top" id="dropDown">
        <div slot="dropdown-content">
          <paper-item on-click="createSplitLayout" id="vert">Column</paper-item>
          <paper-item on-click="createSplitLayout" id="horz">Row </paper-item>
          <template is="dom-if" if="{{!freeze}}">
            <paper-item on-click="deleteSplitLayout" id="delete">Delete</paper-item>
          </template>
          <template is="dom-if" if="{{!showCompChart}}" restamp="true">
            <paper-item on-click="showChart">Add Chart</paper-item>
          </template>
          <template is="dom-if" if="{{showCompChart}}" restamp="true">
            <paper-item on-click="removeChart" >Remove Chart</paper-item>
          </template>
        </div>
      </iron-dropdown>
      <!-- <template is="dom-if" if="{{!showCompChart}}" restamp="true">
        <paper-icon-button icon="add" on-click="showChart" class="addRemoveBtn">Add/Remove Chart</paper-icon-button>
      </template>
      <template is="dom-if" if="{{showCompChart}}" restamp="true">
        <paper-icon-button icon="remove" on-click="removeChart" class="addRemoveBtn">Add/Remove Chart</paper-icon-button>
      </template> -->
    </header>
    <template is="dom-if" if="[[chartAvailabilityChk(itemObj,childSource)]]" restamp="true">
      <div id="chartBox">
        <!-- [[itemObj.chart]] -->
      </div>
    </template>
    <template is="dom-if" if="[[childSource.length]]" restamp="true">
      <recursive-elem uuid="[[uuid]]" split-data="{{childSource}}" id="{{id}}" vertical="[[itemObj.vertical]]"></recursive-elem>
    </template>
    </div>
  </template>
  <script>
    class innerLayoutDiv extends ReduxMixinBehavior(Polymer.Element){
      static get is(){
        return "inner-layout-div"
      }
      static get properties(){
        return{
          align:{
            type:Boolean,
            notify:true
          },
          valign:{
            type:Boolean,
            value:false,
            notify:true
          },
          freeze:{
            type:String,
            value:false,
            notify:true
          },
          showCompChart:{
            type:Boolean
          },
          style:{
            type:String
          },
          chartUUID:{
            type:String
          },
          chartIdChk:{
            type:Boolean,
            observer:"checkChartId"
          },
          childObj:{
            type:Object,
            value:()=>{
              return{
                "id": "",
                "vertical": false,
                "freeze": false,
                "style": "ssss",
                "chart": "",
                "chartId":"",
                "paragraphId":"",
                "showCompChart":false,
                "children": []
              }
            }
          },
          chartData:{
            type:Object,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let compositeChartData = chartPath && chartPath.compositeChartData
              return compositeChartData
            }
          },
          layoutAreaChk:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let layoutAreaChk = chartPath && chartPath.layoutAreaChk
              return layoutAreaChk
            }
          },
          chartAvailableModalChk:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let chartAvailableModalChk = chartPath && chartPath.chartAvailableModalChk
              return chartAvailableModalChk
            }
          },
          currentObjNested:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let currentObjNested = chartPath && chartPath.currentObjNested
              return currentObjNested
            }
          },
          compChartObjs:{
            type:Object,
            statePath(state){
              var chartPath = state.charts[this.uuid]
              let keyChk = chartPath && Object.keys(chartPath.inputs).length
              let compChartInputs = keyChk ? chartPath.inputs:{}
              let compChartAxisKeys = keyChk && Object.keys(chartPath.inputs)
              let compChartSettings = chartPath && state.charts[this.uuid].settings
              let parentId=this.uuid.split("@")[0]
              let source = state.data[parentId].source
              let externals = state.data[parentId].externals
              let objAssignChk = (chartPath && chartPath.settings)
              let stacked = objAssignChk&&chartPath.settings.stacked.value
              let group = objAssignChk&&chartPath.settings.group.value
              return {compChartInputs,compChartAxisKeys,compChartSettings,source,externals,stacked,group}
            }
          },
          chartWidth:{
            type:String
          },
          trackWidth:{
            type:Boolean,
            observer:"getChildWidth"
          },
          trackChartObj:{
            type:Object,
            notify:true
          }

        }
      }
      static get actions() {
        return {
          addUpdateChartData(addUpdateChartData) {
            return {
              type: 'ADD_UPDATE_COMPOSITE_CHART_DATA',
              value: addUpdateChartData
            }
          },
          splitAreaChk(layoutAreaChk) {
            return {
              type: 'COMPOSITE_SPLIT_AREA_CHK',
              value: layoutAreaChk
            }
          },
          chartAvailableModal(chartAvailableChk) {
            return {
              type: 'CHART_AVAILABLE_MODAL_CHK',
              value: chartAvailableChk
            }
          },
          currentObjNested(currentObjNested) {
            return {
              type: 'CURRENT_NESTED_OBJ',
              value: currentObjNested
            }
          },
          currentChartDeleted(currentChartDeleted) {
            return {
              type: 'CURRENT_CHART_DELETED',
              value: currentChartDeleted
            }
          }

        }
      }
      getChildWidth(){
        let trackChartId = this.trackChartObj.trackChartId,
            trackChartIdChk = this.trackChartObj.trackChartIdChk
        trackChartIdChk?this.set("trackChartObj.trackChartId",[]):trackChartId
        if(this.chartUUID){
          let chart = this.root.querySelector("#chartBox").children[0]
          trackChartIdChk?this.unshift("trackChartObj.trackChartId",chart):
          trackChartId.indexOf(chart)==-1 && this.push("trackChartObj.trackChartId",chart)

          let chartWidth = this.offsetWidth-50
          trackChartId[1] == chart && (chartWidth = this.parentNode.offsetWidth - (trackChartId[0].chartWidth+70))

          chart.set("chartWidth",chartWidth)
          chart.redraw()

          trackChartIdChk && this.set("trackChartObj.trackChartIdChk",false)
        }
        let getObj = this.createNewIdNestedObj(this.id)
        let curntObjNested = getObj.currentObjNested
        let style = this.getAttribute("style")
        this.set(curntObjNested+".style",style)
        this.dispatch("addUpdateChartData", {uuid:this.uuid,chartData:this.chartData})

      }
      chartAvailabilityChk(itemObj,child){
        this.set("chartIdChk",child.length<=0 && itemObj.chart!="")
        return child.length<=0 && itemObj.chart!=""
      }
      checkChartId(chartIdChk){
        this.set("showCompChart",this.itemObj.showCompChart)
        this.setAttribute("style",this.itemObj.style)
        chartIdChk && setTimeout(()=>{
          let chart = document.createElement(this.itemObj.chart)
          this.set("chartUUID",this.itemObj.chartId)
          chart.id=this.chartUUID
          chart.parentId=this.itemObj.paragraphId
          chart.showCompChart=this.showCompChart
          chart.set("compChartObjs",this.compChartObjs)
          chart.set("chartWidth",(this.offsetWidth-50))

          this.root.querySelector("#chartBox").appendChild(chart)
        })
      }
      showDropDown(){
        this.$.dropDown.open();
      }
      showChart() {
        this.getCurrentNestedObj()
        this.set("chartAvailableModalChk",!this.chartAvailableModalChk)
        this.dispatch("chartAvailableModal", {uuid:this.uuid,chartAvailableModalChk:this.chartAvailableModalChk})
        this.set("trackChartObj.trackChartIdChk",true)
      }
      getCurrentNestedObj(){
        let getObj = this.createNewIdNestedObj(this.id)
        let curntObjNested = getObj.currentObjNested
        this.set("currentNestedObj", curntObjNested)
        this.dispatch("currentObjNested", {uuid:this.uuid,currentNestedObj:this.currentNestedObj})
      }

      removeChart(){
        let getObj = this.createNewIdNestedObj(this.id)
        let chartRemoveChk = true
        this.chartIsAvailableSetChildData("","",getObj,chartRemoveChk)
        this.dispatch("currentChartDeleted", {uuid:this.chartUUID})
        this.updateObjRedux()
        this.set("trackChartObj.trackChartIdChk",true)
      }
      // checkDialog(){
      //
      // }
      constructor(){
        super()
      }
      createSplitLayout(e){
        let getId=this.id
        let itemId, itemId1
        let getObj = this.createNewIdNestedObj(getId)

        let parentId = getObj.parentId,
            objIdx = getObj.objIdx,
            ObjNested = getObj.ObjNested,
            parentObj = getObj.parentObj

        if(this.get(ObjNested).length==2){
          itemId = getId+"_0"
          let getNewObj = this.createNewIdNestedObj(itemId)
          ObjNested = getNewObj.ObjNested
          parentObj = getNewObj.parentObj
          let showCompChart = this.get(parentObj).showCompChart
          showCompChart&&this.chartIsAvailableSetChildData(parentObj,showCompChart)
        } else {
          itemId = parentId+"_"+(objIdx+1)
        }
        this.set("childObj.id",itemId)
        this.push(ObjNested,this.childObj)
        let verticalKey = parentObj+".vertical",
            vertical = e.currentTarget.id=='horz'
        this.set(verticalKey,vertical)
        this.set("trackChartObj.trackChartIdChk",true)
        this.updateObjRedux()
        this.$.dropDown.close();
      }
      chartIsAvailableSetChildData(parentObj,showCompChart,getObj,chartRemoveChk){
        if(getObj){
          let parentNested = getObj.ObjNested
          let updatedObj = this.get(parentNested).filter(item=>item.id!=this.id)
          let parentObj = getObj.parentObj
          this.set(parentObj+".showCompChart",false)
          this.set(parentObj+".chartId","")
          this.set(parentObj+".chart","")
          this.set(parentObj+".paragraphId","")
          if(chartRemoveChk){
            let currentObjNested = getObj.currentObjNested
            this.set(currentObjNested+".showCompChart",false)
            this.set(currentObjNested+".chartId","")
            this.set(currentObjNested+".chart","")
            this.set(currentObjNested+".paragraphId","")
          }else{
            this.set(parentNested,updatedObj)
          }
        }else{
          let chartId = this.get(parentObj).chartId
          let paragraphId = this.get(parentObj).paragraphId
          let chart = this.get(parentObj).chart
          this.set("childObj.showCompChart",showCompChart)
          this.set("childObj.chartId",chartId)
          this.set("childObj.chart",chart)
          this.set("childObj.paragraphId",paragraphId)
        }
      }
      updateObjRedux(){
        this.dispatch("addUpdateChartData", {uuid:this.uuid,chartData:this.chartData})
        this.set("layoutAreaChk",!this.layoutAreaChk)
        this.dispatch("splitAreaChk", {uuid:this.uuid,layoutAreaChk:this.layoutAreaChk})
      }
      createNewIdNestedObj(getId){
        let splitId=getId.split("_")
        let assignId = getId.split("_")
        let splitIdSize = splitId.length
        let objIdx = (+splitId[splitIdSize-1])
        splitId.pop()
        let parentObj = splitId.join(".children."),
            parentId = splitId.join("_"),
            ObjNested = splitId.join(".children.")+".children",
            currentObjNested = assignId.join(".children.")

        return{parentId,ObjNested,objIdx,parentObj,currentObjNested}
      }
      deleteSplitLayout(e){
        let getObj = this.createNewIdNestedObj(this.id)
        this.chartIsAvailableSetChildData("","",getObj)
        this.updateObjRedux()
        this.set("trackChartObj.trackChartIdChk",true)
        this.$.dropDown.close();
      }
    }
    customElements.define(innerLayoutDiv.is, innerLayoutDiv)
  </script>
</dom-module>
