<link href="../behaviors/redux-mixins-behavior.html" rel='import'>
<link rel="import" href="recursive-elem.html">

<dom-module id="inner-layout-div">
  <template>
    <style>
      :host{
        min-height: 40vh;
      }
      header{
        border-bottom:1px #f6f6f6 solid;
      }
      #splitBox{
        position: relative;
      }
      #dropDown{
        margin-top:20px;
        border: 1px #e9e9e9 solid;
        background-color: white;
      }
      #dropDown paper-item{
        min-width: 49px;
        min-height: 16px;
        cursor: pointer;
        font: 10px sans-serif;
        border-bottom:none;
        padding: 2px 7px;
      }
      #dropDown paper-item+paper-item,
      #dropDown paper-item+dom-if+paper-item,
      #dropDown paper-item+dom-if+dom-if+paper-item{
        border-top: 1px #e9e9e9 solid;
      }
      .paperIconBtn, .addRemoveBtn{
        padding:5px;
        width: 25px;
        height: 25px;
        color: #939393
      }
      :host #splitter{
        display:none;
      }
      .warningMsg{
        position: absolute;
        top: 171px;
        left: 15%;
        font-weight: bold;
      }
      .warningMsg.chartMsg{
        left: 5%;
      }

    </style>
    <div id="splitBox">
      <template is="dom-if" if="[[!readOnly]]">
        <header>
        <paper-icon-button icon="more-horiz" slot="dropdown-trigger" on-click="showDropDown" class="paperIconBtn">select</paper-icon-button>
        <iron-dropdown horizontal-align="left" vertical-align="top" id="dropDown" allow-outside-scroll>
          <div slot="dropdown-content">
            <paper-item on-click="createSplitLayout" id="vert">Column</paper-item>
            <paper-item on-click="createSplitLayout" id="horz">Row </paper-item>
            <template is="dom-if" if="[[!itemObj.freeze]]">
              <paper-item on-click="deleteSplitLayout" id="delete">Delete</paper-item>
            </template>
            <template is="dom-if" if="[[!isCompsiteChart]]" restamp="true">
              <paper-item on-click="showChart">Add Chart</paper-item>
            </template>
            <template is="dom-if" if="[[isCompsiteChart]]" restamp="true">
              <paper-item on-click="removeChart" >Remove Chart</paper-item>
            </template>
          </div>
        </iron-dropdown>
      </header>
    </template>
    <template is="dom-if" if="[[chartAvailabilityChk(itemObj,childSource)]]" restamp="true">
      <div id="chartBox"> </div>
    </template>
    <template is="dom-if" if="[[childSource.length]]" restamp="true">
      <recursive-elem uuid="[[uuid]]" split-data="{{childSource}}" id="{{id}}" vertical-pos="[[itemObj.vertical]]"></recursive-elem>
    </template>
    </div>
  </template>
  <script>
  /**
* @polymer
* @extends HTMLElement
*/
    class innerLayoutDiv extends ReduxMixinBehavior(Polymer.Element){
      static get is(){
        return "inner-layout-div"
      }
      static get properties(){
        return{
          readOnly:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let readOnly = chartPath && chartPath.readOnly
              return readOnly
            }
          },
          isCompsiteChart:{
            type:Boolean
          },
          style:{
            type:String
          },
          chartUUID:{
            type:String
          },
          chartIdChk:{
            type:Boolean,
            observer:"checkChartId"
          },
          childObj:{
            type:Object,
            value:()=>{
              return{
                "id": "",
                "vertical": false,
                "freeze": false,
                "style": "",
                "chart": "",
                "chartId":"",
                "paragraphId":"",
                "isCompsiteChart":false,
                "children": []
              }
            }
          },
          chartData:{
            type:Object,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let compositeChartData = chartPath && chartPath.compositeChartData
              return compositeChartData
            }
          },
          layoutAreaChk:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let layoutAreaChk = chartPath && chartPath.layoutAreaChk
              return layoutAreaChk
            }
          },
          chartAvailableModalChk:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let chartAvailableModalChk = chartPath && chartPath.chartAvailableModalChk
              return chartAvailableModalChk
            }
          },
          currentObjNested:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let currentObjNested = chartPath && chartPath.currentObjNested
              return currentObjNested
            }
          },
          chartWidth:{
            type:String
          },
          trackWidth:{
            type:Boolean,
            observer:"getChildWidth"
          },
          trackChartObj:{
            type:Object,
            notify:true
          },
          refIds:{
            type:Array,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let refIds =  chartPath && chartPath.refIds
              return refIds?refIds:[]
            }
          },
          filterIdx:{
            type:Number,
            statePath(state){
              let chartId = this.itemObj.chartId
              // chartId = chartId?chartId:this.chartUUID
              let chartPath = state.charts[chartId]
              let filterIdx = chartPath && chartPath.filterIdx
              return filterIdx>=0?filterIdx:-1
            }
          },
          compfilterGblChk:{
            type:Boolean,
            statePath(state){
              let chartPath = state.charts[this.uuid]
              let compfilterGblChk = chartPath && chartPath.compfilterGblChk
              return compfilterGblChk
            }
          }
        }
      }
      static get actions() {
        return {
          addUpdateChartData(addUpdateChartData) {
            return {
              type: 'ADD_UPDATE_COMPOSITE_CHART_DATA',
              value: addUpdateChartData
            }
          },
          splitAreaChk(layoutAreaChk) {
            return {
              type: 'COMPOSITE_SPLIT_AREA_CHK',
              value: layoutAreaChk
            }
          },
          chartAvailableModal(chartAvailableChk) {
            return {
              type: 'CHART_AVAILABLE_MODAL_CHK',
              value: chartAvailableChk
            }
          },
          currentObjNested(currentObjNested) {
            return {
              type: 'CURRENT_NESTED_OBJ',
              value: currentObjNested
            }
          },
          currentChartDeleted(currentChartDeleted) {
            return {
              type: 'CURRENT_CHART_DELETED',
              value: currentChartDeleted
            }
          },
          addRefrenceSrc(addRefrenceSrc) {
            return {
              type: 'ADD_COMP_REFRENCE_SRC',
              value: addRefrenceSrc
            }
          },
          filterIdxGbl(filterIdxGbl) {
            return {
              type: 'ADD_FILTER_IDX_GBL',
              value: filterIdxGbl
            }
          },
          addRefrenceIds(refIds) {
            return {
              type: 'ADD_REFRENCE_IDS_GBL',
              value: refIds
            }
          },
          addfilterIdx(filterIdx) {
            return {
              type: 'ADD_FILTER_IDX',
              value: filterIdx
            }
          },
          compfilterGblChk(compfilterGblChk) {
            return {
              type: 'COMP_FILTER_GBL_CHK',
              value: compfilterGblChk
            }
          },
          compfilterChk(compfilterChk) {
            return {
              type: 'COMP_FILTER_CHK',
              value: compfilterChk
            }
          },
          compFilterKeys(filterKeys) {
            return {
              type: 'COMP_FILTER_KEYS',
              value: filterKeys
            }
          }

        }
      }
      chartLayoutUpdate(){
        this.set("layoutAreaChk",!this.layoutAreaChk)
        this.dispatch("splitAreaChk", {uuid:this.uuid,layoutAreaChk:this.layoutAreaChk})
      }

      getChildWidth(){
        let trackChartId = this.trackChartObj.trackChartId,
            trackChartIdChk = this.trackChartObj.trackChartIdChk
        trackChartIdChk?this.set("trackChartObj.trackChartId",[]):trackChartId
        if(this.chartUUID){
          let chart = this.root.querySelector("#chartBox").children[0]
          trackChartIdChk?this.unshift("trackChartObj.trackChartId",chart):
          trackChartId.indexOf(chart)==-1 && this.push("trackChartObj.trackChartId",chart)

          let chartWidth = this.offsetWidth
          trackChartId[1] == chart && !this.parentNode.vertical && (chartWidth = this.parentNode.offsetWidth - (trackChartId[0].chartWidth))
          let chartHeight = this.offsetHeight
          trackChartId[1] == chart && this.parentNode.vertical && (chartHeight = this.parentNode.offsetHeight - (trackChartId[0].chartHeight))

          chartWidth = chartWidth-50
          chartHeight = chartHeight-50
          chart.set("chartWidth",chartWidth)
          chart.set("chartHeight",chartHeight)
          chart.set("chartVertical",this.parentNode.vertical)
          chart.redraw()

          trackChartIdChk && this.set("trackChartObj.trackChartIdChk",false)
        }
        let getObj = this.createNewIdNestedObj(this.id)
        let curntObjNested = getObj.currentObjNested
        let style = this.getAttribute("style")
        this.set(curntObjNested+".style",style)
        this.dispatch("addUpdateChartData", {uuid:this.uuid,chartData:this.chartData})

      }
      chartAvailabilityChk(itemObj,child){
        this.set("chartIdChk",child.length<=0 && itemObj.chart!="")
        return child.length<=0 && itemObj.chart!=""
      }
      checkChartId(chartIdChk){
        this.set("isCompsiteChart",this.itemObj.isCompsiteChart)
        this.setAttribute("style",this.itemObj.style)
        chartIdChk && setTimeout(()=>{
          let chart = document.createElement(this.itemObj.chart)
          this.set("chartUUID",this.itemObj.chartId)
          chart.compUUID = this.uuid
          chart.id=this.chartUUID
          chart.parentId=this.itemObj.paragraphId
          chart.isCompsiteChart=this.isCompsiteChart
          // chart.set("compChartObjs",this.compChartObjs)
          chart.set("chartWidth",(this.offsetWidth-50))
          chart.set("chartHeight",this.offsetHeight)
          chart.set("chartVertical",this.parentNode.vertical)

          this.root.querySelector("#chartBox").appendChild(chart)
        })
      }
      showDropDown(){
        let dialog = this.$.splitBox.querySelector("#dropDown")
        dialog.open();
      }
      showChart() {
        this.getCurrentNestedObj()
        this.set("chartAvailableModalChk",!this.chartAvailableModalChk)
        this.dispatch("chartAvailableModal", {uuid:this.uuid,chartAvailableModalChk:this.chartAvailableModalChk})
        this.set("trackChartObj.trackChartIdChk",true)
      }
      getCurrentNestedObj(){
        let getObj = this.createNewIdNestedObj(this.id)
        let curntObjNested = getObj.currentObjNested
        this.set("currentNestedObj", curntObjNested)
        this.dispatch("currentObjNested", {uuid:this.uuid,currentNestedObj:this.currentNestedObj})
      }

      removeChart(){
        let getObj = this.createNewIdNestedObj(this.id)
        let chartRemoveChk = true
        this.chartIsAvailableSetChildData("","",getObj,chartRemoveChk)
        this.filterIdx!=-1 && this.deleteChartFilter()
        this.dispatch("currentChartDeleted", {uuid:this.chartUUID})
        this.updateObjRedux()
        this.set("trackChartObj.trackChartIdChk",true)
      }
      deleteChartFilter(){
        let refIds = this.refIds
        let filterIdx = this.filterIdx
        let spliceIds = refIds.splice(filterIdx+1)
        let filterIdxGbl = refIds.length==0?0:refIds.length==2?1:filterIdx
        this.dispatch("compfilterGblChk", {uuid:this.uuid,compfilterGblChk:!this.compfilterGblChk})
        this.dispatch("addRefrenceIds", {uuid:this.uuid,refIds:refIds})
        this.dispatch("filterIdxGbl", {uuid:this.uuid,filterIdxGbl:filterIdxGbl})
        spliceIds.forEach(itemId=>{
          if(this.chartUUID!=itemId){
            this.dispatch("addfilterIdx", {uuid:itemId,filterIdx:-1})
            this.dispatch("compfilterChk", {uuid:itemId,compfilterChk:false})
            this.dispatch("addRefrenceSrc", {uuid:itemId,refrenceSrc:[]})
            this.dispatch("compFilterKeys", {uuid:itemId,filterKeys:[]})
          }
        })
      }
      // checkDialog(){
      //
      // }
      constructor(){
        super()
      }
      createSplitLayout(e){
        let getId=this.id
        let itemId, itemId1
        let getObj = this.createNewIdNestedObj(getId)

        let parentId = getObj.parentId,
            objIdx = getObj.objIdx,
            ObjNested = getObj.ObjNested,
            parentObj = getObj.parentObj

        if(this.get(ObjNested).length==2){
          itemId = getId+"_0"
          let getNewObj = this.createNewIdNestedObj(itemId)
          ObjNested = getNewObj.ObjNested
          parentObj = getNewObj.parentObj
          let isCompsiteChart = this.get(parentObj).isCompsiteChart
          isCompsiteChart&&this.chartIsAvailableSetChildData(parentObj,isCompsiteChart)
        } else {
          itemId = parentId+"_"+(objIdx+1)
        }
        this.set("childObj.id",itemId)
        this.push(ObjNested,this.childObj)
        let verticalKey = parentObj+".vertical",
            vertical = e.currentTarget.id=='horz'
        this.set(verticalKey,vertical)
        this.set("trackChartObj.trackChartIdChk",true)
        this.updateObjRedux()
        let dialog = this.$.splitBox.querySelector("#dropDown")
        dialog.close();
      }
      chartIsAvailableSetChildData(parentObj,isCompsiteChart,getObj,chartRemoveChk){
        if(getObj){
          let parentNested = getObj.ObjNested
          let updatedObj = this.get(parentNested).filter(item=>item.id!=this.id)
          let parentObj = getObj.parentObj
          this.set(parentObj+".isCompsiteChart",false)
          this.set(parentObj+".chartId","")
          this.set(parentObj+".chart","")
          this.set(parentObj+".paragraphId","")
          if(chartRemoveChk){
            let currentObjNested = getObj.currentObjNested
            this.set(currentObjNested+".isCompsiteChart",false)
            this.set(currentObjNested+".chartId","")
            this.set(currentObjNested+".chart","")
            this.set(currentObjNested+".paragraphId","")
          }else{
            this.set(parentNested,updatedObj)
          }
        }else{
          let chartId = this.get(parentObj).chartId
          let paragraphId = this.get(parentObj).paragraphId
          let chart = this.get(parentObj).chart
          this.set("childObj.isCompsiteChart",isCompsiteChart)
          this.set("childObj.chartId",chartId)
          this.set("childObj.chart",chart)
          this.set("childObj.paragraphId",paragraphId)
        }
      }
      updateObjRedux(){
        this.dispatch("addUpdateChartData", {uuid:this.uuid,chartData:this.chartData})
        this.chartLayoutUpdate()
      }
      createNewIdNestedObj(getId){
        let splitId=getId.split("_")
        let assignId = getId.split("_")
        let splitIdSize = splitId.length
        let objIdx = (+splitId[splitIdSize-1])
        splitId.pop()
        let parentObj = splitId.join(".children."),
            parentId = splitId.join("_"),
            ObjNested = splitId.join(".children.")+".children",
            currentObjNested = assignId.join(".children.")

        return{parentId,ObjNested,objIdx,parentObj,currentObjNested}
      }
      deleteSplitLayout(e){
        let getObj = this.createNewIdNestedObj(this.id)
        this.chartIsAvailableSetChildData("","",getObj)
        this.filterIdx!=-1 && this.deleteChartFilter()
        this.chartUUID && this.dispatch("currentChartDeleted", {uuid:this.chartUUID})
        this.updateObjRedux()
        this.set("trackChartObj.trackChartIdChk",true)
        let dialog = this.$.splitBox.querySelector("#dropDown")
        dialog.close();
      }
    }
    customElements.define(innerLayoutDiv.is, innerLayoutDiv)
  </script>
</dom-module>
