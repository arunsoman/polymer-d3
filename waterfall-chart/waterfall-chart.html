<!-- This chart is specifically built to be transformed into a 100% chart -->
<link rel="import" href="../display-component/base-chart.html">
<dom-module id="waterfall-chart">
  <template>
    <style>
      #chartContainer{
        margin:0 auto;
        font: 10px sans-serif;
        position: relative;
      }
      .rect {
            border: solid 1px #ccc;
            font: 10px sans-serif;
            shape-rendering: crispEdges;
        }

        rect.positive {
            fill: rgb(8, 37, 131);
        }

        rect.negative {
            fill: rgb(255, 0, 0);
        }

        .trend-line {
            fill: none;
            stroke: rgb(0, 138, 0);
            stroke-width: 1.5px;
            stroke-dasharray: 10, 10;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }
    </style>
    <chart-input-group  uuid="[[uuid]]">
      <chart-input slot="chart-input" axis="x" label="Key"></chart-input>
      <chart-input slot="chart-input" axis="y" label="Value" accept="number"></chart-input>
    </chart-input-group>
    <chart-settings uuid="[[uuid]]"></chart-settings>
    <div id="chartContainer"></div>
  </template>
  <script>
    class waterfallChart extends baseChart{
      static get is(){
        return "waterfall-chart"
      }
      static get properties(){
        return{}
      }
      constructor(){
        super()
      }
      redraw() {
        this.draw(this._paint(this._compute()));
      }
      _compute() {
        //assign group value
        let axisIndex = 2
        //"hasInputs" for avoid error from chart
        if(!this.hasInputs(axisIndex))return false
        //axis are mentioned in the chart-input module
        let itemX,itemY
        //axis inputs selectedValue assigin
        itemX = this.inputs[this.x].selectedValue[0]
        itemY = this.inputs[this.y].selectedValue[0]

        let parseDate = d3.time.format('%Y-%m-%d').parse;
        let width = +this.settings.width.value,
            height = +this.settings.height.value,
            margin = {top: 5, right: 40, bottom: 20, left: 120},
            label= this.settings.legend.values
            //margin = {top: +this.settings.margin.value.top, right: +this.settings.margin.value.right, bottom: +this.settings.margin.value.bottom, left: +this.settings.margin.value.left}
        width = width - margin.left - margin.right
        height = height - margin.top - margin.bottom

        let color = d3.scale.category20();

        //get chart data once pass "x and y" into the "getChartData" method
        let source = this.getChartData(itemX, itemY)
        let chartData = source.data
        let srcLength = source.dataLength
        let xDelta = width / srcLength
        height = height+20
        margin.xMargin = margin.left + margin.right
        margin.yMargin = margin.top + margin.bottom
        margin.xAxisMrgn = 35

        // define y scale
        let yScale = d3.scale.linear()
        //define x and y
        let x = d3.scale.ordinal()
                  .rangeRoundBands([0, width], 0.05)
                  .domain(source.sourcemap),
            y = d3.scale.linear().range([height, 0])
        //define x and y axis
        let xAxis = d3.svg.axis()
                      .scale(x)
                      .orient("bottom"),
            yAxis = d3.svg.axis()
                      .scale(y)
                      .ticks(4)
                      .orient("left")

        // Calculate scale of the y-axis for drawing waterfall bars
        let min = source.min, max = source.max
        y.domain([min, max]);
        yScale.domain([min, max]).range([0, height]);

        //// Trend line
        let line = d3.svg.line()
            .x((d, i)=>(i * xDelta + xDelta * .5 + margin.xMargin / 2))
            .y(d=>(d.value < 0) ? height - yScale(d.cumulativeSum - d.value) : height - yScale(d.cumulativeSum));

        return {
          width,
          height,
          margin,
          xDelta,
          yScale,
          xAxis,
          yAxis,
          line,
          chartData,
          color,
          label
        }
      }
      _paint(obj) {
        this.clear()
        if (!obj) return false
        //Draw Waterfall chart and append the svg canvas to the page
        let parentG = d3.select(this.$.chartContainer).append("svg")
            .attr("width", obj.width + obj.margin.xMargin)
            .attr("height", obj.height + obj.margin.yMargin)
            .append("g")
            .attr("transform", "translate(" + obj.margin.xMargin + "," + (obj.margin.yMargin-20) + ")");

        // Calculate and add rectangles to the chart
        parentG.selectAll("rect")
            .data(obj.chartData)
            .enter()
            .append("rect")
            .attr("class", d=>(d.value < 0) ? "negative" : "positive")
            .attr("x", (d, i)=>(i * obj.xDelta + obj.margin.xAxisMrgn))
            .attr("y", (d, i)=>(d.value < 0) ? obj.height - obj.yScale(d.cumulativeSum - d.value) : obj.height - obj.yScale(d.cumulativeSum))
            .attr("width", d=>obj.xDelta)
            .attr("height", d=>obj.yScale(Math.abs(d.value)))
            //.style("fill", d=>obj.color(d.value))

          // Add labels to the rectangles
          let barLabels = parentG.append("g")
              .selectAll('text')
              .data(obj.chartData)
              .enter()
              .append("text")
              .attr("x", (d, i)=>(i * obj.xDelta + obj.xDelta * .5 + obj.margin.xMargin / 2))
              .attr("y", (d, i)=>(d.value < 0) ? obj.height - obj.yScale(d.cumulativeSum) + 25 : obj.height - obj.yScale(d.cumulativeSum))
              .attr('dy', -5)
              .text(d=>d.cumulativeSum.toFixed(2));
          /// Draw x- and y- axis lines
          parentG.append("g")
              .attr("class", "axis")
              .attr("transform", "translate(" + obj.margin.xAxisMrgn + "," + obj.height + ")")
              .call(obj.xAxis);

          parentG.append("g")
              .attr("class", "axis")
              .call(obj.yAxis);

          parentG.append("path")
              .datum(obj.chartData)
              .attr("class", "trend-line")
              .attr("d", obj.line);
        d3.select(this.$.chartContainer).style({"width":obj.width+ obj.margin.xMargin+"px"})
      }
      // populate chart data
      getChartData(itemX, itemY){
        let sourceData = this.source.reduce((old,newVal)=>{
          old[newVal[itemX]]=(old[newVal[itemX]]||0)+(+newVal[itemY])
          return old
        },{})
        let parseDate = d3.time.format('%Y-%m-%d').parse;
        let source  = Object.keys(sourceData).map(item=>{
          let dateV = String(item).split(" ")[0]
          let dateChk = parseDate(dateV)
          let itemSet = dateChk?dateV:item
          return {xKey:itemSet,yKey:sourceData[item]}
        })

        let max = 0, min = 0, cumSum = 0;
        let data =[]
        source.forEach(function (d) {
            cumSum += d.yKey;
            cumSum < min && (min = cumSum)
            cumSum > max && (max = cumSum)
            data.push({value: d.yKey, cumulativeSum: cumSum,xKey:d.xKey});
        });
        let dataLength = source.length
        let sourcemap = source.map(d=>d.xKey)
        return {data, dataLength, sourcemap, max, min}
      }
    }
    customElements.define(waterfallChart.is, waterfallChart)
  </script>
</dom-module>
