<link rel="import" href="../display-component/base-chart.html">
<dom-module id='heat-map'>
  <template>
    <style>
      .axis path,
      .axis line {
      fill: none;
      stroke: black;
      shape-rendering: crispEdges;
      }

      .axis text {
       font-family: sans-serif;
       font-size: 11px;
      }
      #chartContainer{
        margin:0 auto;
        font: 10px sans-serif;
      }
    </style>
    <chart-input-group  uuid="[[uuid]]">
      <chart-input slot="chart-input" axis="x" label="Key"></chart-input>
      <chart-input slot="chart-input" axis="y" label="Key"></chart-input>
      <chart-input slot="chart-input" axis="z" label="Value" accept="number"></chart-input>
    </chart-input-group>
    <chart-settings uuid="[[uuid]]"></chart-settings>
    <div id="chartContainer"></div>
  </template>
  <script>
    /**
    * @polymer
    * @extends HTMLElement
    */
    class heatMap extends baseChart{
      static get is(){
        return"heat-map"
      }
      static get properties(){
        return{
        }
      }
      constructor(){
        super()
      }
      redraw() {
        this.draw(this._paint(this._compute()));
      }
      _compute() {
        let axisIndex = 3
        //"chartProp" define for chart axis and properties
        let arg = {axisIndex}
        let chartProp = this.getChartProperties(arg)
        if(!chartProp)return false

        chartProp.colors = ["#2980B9", "#E67E22", "#27AE60", "#27AE60","#253494","#081d58"]

        //get chart data once pass "x and y" into the "getChartData" method
        let source = this.getChartData(chartProp.itemX, chartProp.itemY,chartProp.itemZ,chartProp.parseDate)
        let chartData = source.data;

        let xKey=source.xKey,
            yKey = source.yKey

        let itemSize = 18,
            cellSize = itemSize - 1

        let x_elements = d3.set(chartData.map(item=>item[xKey])).values(),
            y_elements = d3.set(chartData.map(item=>item[yKey])).values();

        let xScale = d3.scale.ordinal()
            .domain(x_elements)
            .rangeBands([0, x_elements.length * itemSize]);
        let xAxis = d3.svg.axis()
            .scale(xScale)
            .tickFormat(function (d) {
                return d;
            })
            .orient("top");
        let yScale = d3.scale.ordinal()
          .domain(y_elements)
          .rangeBands([0, y_elements.length * itemSize]);

        let yAxis = d3.svg.axis()
            .scale(yScale)
            .tickFormat(function (d) {
                return d;
            })
            .orient("left");
        let colorScale = d3.scale.threshold()
            .domain([0.85, 1])
            .range(chartProp.colors);

        return {
          cellSize,
          xAxis,
          yAxis,
          xScale,
          yScale,
          xKey,
          yKey,
          colorScale,
          calendarChart,
          chartData,
          chartProp
        }
      }

      _paint(obj) {
        this.clear()
        if (!obj) return false
        // render chart
        let parentG = d3.select(this.$.chartContainer)
            .append("svg")
            .attr({"width": obj.chartProp.width + obj.chartProp.margin.xMargin,
                    "height": obj.chartProp.height + obj.chartProp.margin.yMargin})
            .append("g")
              .attr("transform", "translate(" + obj.chartProp.margin.left + "," + obj.chartProp.margin.top+ ")");
        let cells = parentG.selectAll('rect')
                    .data(obj.chartData)
                    .enter().append('g').append('rect')
                    .attr({'class':'cell','width':obj.cellSize, 'height':obj.cellSize})
                    .attr('y', d=>obj.yScale(d[obj.yKey]))
                    .attr('x', d=>obj.xScale(d[obj.xKey]))
                    .attr('fill', (d)=>{return obj.colorScale(d.value)})
                    // .append("title")
                    // .text(d=>"Value: "+d.value)
        parentG.append("g")
              .attr("class", "y axis")
              .call(obj.yAxis)
              .selectAll('text')
              .attr('font-weight', 'normal');

        parentG.append("g")
              .attr("class", "x axis")
              .call(obj.xAxis)
              .selectAll('text')
              .attr({'font-weight':'normal',"dx":".8em","dy":".5em"})
              .style("text-anchor", "start")
              .attr("transform", d=>"rotate(-65)");

      d3.select(this.$.chartContainer).style({"width":obj.chartProp.width+ obj.chartProp.margin.xMargin+"px"})
      }
      // populate chart data
      getChartData(itemX,itemY,itemZ,parseDate){
          let xKey = this.externals[itemX]["key"],
              yKey = this.externals[itemY]["key"]
          // let parseDate = d3.time.format('%Y-%m-%d').parse

          let data = this.source.map(row=>{
            let splitRowX = String(row[itemX]).split(" ")[0],
                splitRowY = String(row[itemY]).split(" ")[0],
                dateParseRowX = parseDate(String(row[itemX]).split(" ")[0]),
                xRow = dateParseRowX?splitRowX:row[itemX],
                dateParseRowY = parseDate(String(row[itemY]).split(" ")[0]),
                yRow = dateParseRowY?splitRowY:row[itemY]
            return{
              [xKey]:xRow,
              [yKey]:yRow,
              value:row[itemZ]
            }
          })
          return {data,xKey,yKey}
      }
    }
    customElements.define(heatMap.is, heatMap)
  </script>
</dom-module>
