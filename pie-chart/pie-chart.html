<link rel="import" href="../display-component/base-chart.html">
<!-- <link href="../behaviors/redux-mixins-behavior.html" rel='import'> -->
<dom-module id="pie-chart">
  <template>
<style>
  body {
    text-align: center;
  }
  svg {
    font: 29px sans-serif;
  }
  #chartContainer{
    margin:0 auto;
  }
  .legend-items text{
    fill:black
  }
  .legend{
    fill:transparent;
    font-size: 12px;
  }
  </style>
  <chart-input-group  uuid="[[uuid]]">
    <chart-input slot="chart-input" axis="x" label="x-axis"></chart-input>
    <chart-input slot="chart-input" axis="y" label="y-axis"></chart-input>
    <chart-input slot="chart-input" axis="groupBy" label="Group by"></chart-input>
  </chart-input-group>
  <chart-settings uuid="[[uuid]]"></chart-settings>
  <!-- <svg id="svg"></svg> -->
  <div id="chartContainer"></div>
</template>
  <script>
    class pieChart extends baseChart {
      static get is() {
        return 'pie-chart'
      }
      static get properties() {
        return {
          innerRadius: {
            type: Object,
            value: {
              selectedValue: 0
            }
          }
        }
      }
      constructor() {
        super();
      }
      redraw() {
        this.draw(this._paint(this._compute()));
      }
      _compute() {
        //axis are mentioned in the chart-input module
        let itemGrpX = this.x ? this.inputs[this.x].itemGrp : []
        let itemGrpY = this.y ? this.inputs[this.y].itemGrp : []
        let itemChk = itemGrpX.length <= 0 || itemGrpY.length <= 0

        let groupBy = this.groupBy ? this.inputs[this.groupBy].itemGrp : []
        let itemGrpChk = groupBy.length > 0

        if (itemChk) {
          if (!itemGrpChk) {
            return false;
          }
        }
        //"itemChk" for avoid error from chart
        itemChk = itemChk ? !itemGrpChk : itemChk

        let width = this.settings.width.value,
          height = this.settings.height.value,
          label = this.settings.legend.values;
        let innerRadius;
        let radius = Math.min(width, height) / 2;

        if (itemGrpChk) {
          let grpCnt = groupBy.length
          width = (width - 50) / grpCnt
          height = height / grpCnt
          radius = Math.min(width, height) / 2
          innerRadius = radius / 2
        } else {
          width = width
          height = height
          innerRadius = this.innerRadius.selectedValue
        }
        innerRadius = innerRadius;

        let color = d3.scale.category20c();

        //get chart data once pass "itemGrp" into the "getChartData" method
        let itemGrp
        itemGrp = itemGrpChk ? groupBy : itemGrpX.concat.apply(itemGrpX, itemGrpY)

        let chartData
        // let source = this.getChartData(itemGrp)

        let sourcemap = 
        this.source.reduce((old,newVal)=>{
          let xaxis= this.inputs[this.x].selectedValue[0];
          let yaxis= this.inputs[this.y].selectedValue[0];
          old[newVal[xaxis]]=(old[newVal[xaxis]]||0)+newVal[yaxis]
          return old
        },{})
        let source  = Object.keys(sourcemap).map(item=>{return {item,value:sourcemap[item]}})
        if (itemGrpChk) {
          chartData = d3.nest().key(d => d.item).entries(source);
        } else {
          chartData = d3.nest().key(d => d).entries(source);
        }

        let pie = d3.layout.pie()
          .value(d => d.value)
          .sort(null);

        let arc = d3.svg.arc()
          .outerRadius(radius - 10)
          .innerRadius(innerRadius);

        let labelArc = d3.svg.arc()
          .outerRadius(radius - 40)
          .innerRadius(radius - 40);

        return {
          width,
          height,
          color,
          arc,
          pie,
          itemChk,
          chartData,
          label
        }
      }
      _paint(obj) {
        d3.select(this.$.chartContainer).html("")
        if (!obj || obj.itemChk) {
          return false
        }

        this.chartKeys(obj,obj.chartData[0].values,'item');
        let parentG = d3.select(this.$.chartContainer)
          .selectAll("div#chartContainer")
          .data(obj.chartData).enter()

        parentG = parentG.append("div")
          .style({"display":"inline-block","width":obj.width,"height":obj.height})
          .append("svg")
          .attr("width", obj.width)
          .attr("height", obj.height).append("g");
        parentG.append("text")
        .attr("dy", ".35em")
        .attr("text-anchor", "middle")
        .attr("transform", "translate("+(obj.width/2)+","+(obj.height/2)+")")
        .text(function(d) { return d.key; });


        let g = parentG.selectAll('.arc')
          .data(d => obj.pie(d.values))
          .enter().append('g')
          .attr('class', 'arc')
          .attr("data-legend",function(d) {return d.data.item})
          .attr("data-legend-color",this.colorFill.bind(obj))

        let segments = g.append('path')
          .attr('d', obj.arc)
          .style('fill', this.colorFill.bind(obj))
          .attr('class', 'pie-slice');

        segments.attr('transform', 'translate(' + obj.width / 2 + ',' + obj.height / 2 + ')');

        let legend = parentG.append("g")
          .attr("class","legend")
          .attr("transform","translate("+(obj.width*obj.label.position.x)/100+","+(obj.height*obj.label.position.y)/100+")")
          .call(d3.legend)

        d3.select(this.$.chartContainer).style({"width":this.settings.width.value+"px",
          "height":this.settings.height.value+"px"})

        let htmlCallback = d => {
          let gpName = d.data.groupName || d.data.item;
          let str = '<table class="pie-tooltip">' +
            '<tr>' +
            '<td>' + d.data.value + ',</td>' +
            '<td>' + gpName + '</td>' +
            '</tr>' +
            '</table>';
          return str;
        };
        this.attachToolTip(parentG, segments, 'pie-slice', htmlCallback);
      }

    }
    customElements.define(pieChart.is, pieChart)
  </script>
</dom-module>
