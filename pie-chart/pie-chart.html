<link rel="import" href="../display-component/base-chart.html">
<!-- <link href="../behaviors/redux-mixins-behavior.html" rel='import'> -->
<dom-module id="pie-chart">
<template>
  <chart-input-group  uuid="{{uuid}}" input-obj="{{input}}">
    <chart-input input="{{input}}" id="0" slot="chart-input" axis="{{xAxis}}" label="{{xLabel}}" ></chart-input>
    <chart-input input="{{input}}" id="1" slot="chart-input" axis="{{yAxis}}" label="{{yLabel}}" ></chart-input>
  </chart-input-group>
  <h3>[[settings.title]]</h3>
  <chart-legend></chart-legend>
  <chart-settings></chart-settings>
</template>
<script>
  class pieChart extends baseChart{
    static get is(){ return 'pie-chart'}

    static get properties(){
      return{

      }
    }
    constructor(){
      super();

    }

    connectedCallback(){
      super.connectedCallback()
      this._dispatchObj()
    }
    attached(){
      redraw();
    }
    redraw(){
      draw(_paint(_compute()));
    }

    _dispatchObj(){
      let self = this

      let chartProperies={}
      let id= this.uuid
      let settings=this.settings
      let inputs = this.inputs
      let redraw = this.redraw
      console.log("====", this.inputs)
      chartProperies= {id,settings,redraw,inputs}
      this.dispatch("updateChart",chartProperies)

    }
    _compute(){
      let slice = this.inputs[0].selectedValue;
        let sliceSize = this.inputs[1].selectedValue;
        // if slice exists, it would be an array
        if (!slice || !sliceSize) {
            return false;
        }
        let groupBy = this.inputs[2].selectedValue;
        slice = slice[0];
        sliceSize = sliceSize[0];

        let width = this.chartWidth,
            height = this.chartHeight,
            radius = Math.min(width, height) / 2;
        let innerRadius = this.area[6].selectedValue;

        let color = d3.scale.category20c();

        let arc = d3.svg.arc()
            .outerRadius(radius - 10)
            .innerRadius(innerRadius);

        let labelArc = d3.svg.arc()
            .outerRadius(radius - 40)
            .innerRadius(radius - 40);

        let groupedData;
        if (!groupBy) {
            groupedData = d3.nest().key(d => d).entries(this.source);
        } else {
            groupedData = d3.nest().key(d => d[groupBy]).entries(this.source);
        }
        let pie = d3.layout.pie()
            .sort(null)
            .value(function(d) {
                return d[sliceSize];
            });
        return width, height, pie, arc, slice, color
    }
    _paint(width, height, pie, arc, slice, color) {
      this.parentG.attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');
        let me = this;
        if (this.parentG) {
            this.parentG.html('');
        }
        let g = this.parentG.selectAll('.arc')
            .data(pie(me.source))
            .enter().append('g')
            .attr('class', 'arc');

        let segments = g.append('path')
            .attr('d', arc)
            .style('fill', function(d) {
                return color(d.data[slice]);
            })
            .attr('class', 'pie-slice');

        let htmlCallback = d => {
            // temp. setup to check if grouping works
            let gpName = d.data.groupName || d.data[this.inputs[1].selectedValue[0]];
            let str = '<table class="pie-tooltip">' +
                '<tr>' +
                '<td>' + d.data[this.inputs[0].selectedValue] + ',</td>' +
                '<td>' + gpName + '</td>' +
                '</tr>' +
                '</table>';
            return str;
        };
        // attachToolTip: (parentG, elem, customClass, htmlCallback) => {
        this.attachToolTip(this.parentG, segments, 'pie-slice', htmlCallback);
    }
  }
  customElements.define(pieChart.is,pieChart)

</script>
</dom-module>
