<link href="../behaviors/redux-mixins-behavior.html" rel='import'>

<dom-module id="base-chart">
<template >
  <h3>[[title]] </h3>
</template>
<script>

  class baseChart extends Polymer.mixinBehaviors(
    [PolymerD3.toolTipBehavior],ReduxMixinBehavior(Polymer.Element)
    ){
    static get is(){ return 'base-chart'}

    static get properties(){
      return{
        redrawChk:{
          type:Boolean
        },
        sufficiantInputs:{
          type:Boolean,
          value:false
        },
        uuid:{
          type:String
        },
        parentId:{
          type:String
        },
        compUUID:{
          type:String
        },
        axisKeys:{
          type:String,
          statePath(state){
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            let keyChk = chartPath && chartPath.inputs&&Object.keys(chartPath.inputs).length
            let keys = keyChk && Object.keys(chartPath.inputs)
            return keys
            // return this.settingsDisabled&&this.compChartObjs ? this.compChartObjs.compChartAxisKeys:keys
          }
        },
        inputs:{
          type:Array,
          observer:'_chartDraw',
          statePath(state){
            // debugger
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            let keyChk = chartPath && chartPath.inputs&&Object.keys(chartPath.inputs).length
            let inputData = keyChk ? chartPath.inputs:{}
            return inputData
            // return this.settingsDisabled&&this.compChartObjs?this.compChartObjs.compChartInputs:inputData
          },
          readOnly:true
        },
        // x:{
        //   type:String
        // },
        // y:{
        //   type:String
        // },
        // z:{
        //   type:String
        // },
        settings:{
          type:Object,
          observer:'_chartDraw',
          statePath(state){
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            if(chartPath){
              return chartPath.settings;
            }else{
              return {
                title:{uitype:'text',txt:"Title",value:""},
                margin:{uitype:'visual',txt:'Margin',value:{top: 5, right: 20, bottom: 50, left: 20}},
                legend:{uitype:'popup',txt:"Legend Settings",values:{nodes:[],position:{x:85,y:5}}},
                width:{uitype:'number',txt:"Chart width", value:"960"},
                height:{uitype:'number',txt:"Chart Height", value:"500"},
                stacked:{uitype:'boolean',value:false,txt:"Stacked Chart"},
                group:{uitype:'boolean',value:false, txt:"Group Chart"}
              }
            }
          }

        },
        externals:{
          type:Array,
          statePath(state){
            return state.data[this.parentId].externals
          }
        },
        refSource:{
          type:Array,
          statePath(state){
            let chartPath = state.charts
            return chartPath
            // return state.data[this.parentId].source
          }
        },
        source:{
          type:Array,
          statePath(state){
            // let compChartChk = this.settingsDisabled && this.compfilterChk
            let refIdIdxChk = this.settingsDisabled && this.filterIdx>=0 && this.refIds.length
            let refId = refIdIdxChk&& this.refIds[this.filterIdx]
            refId = refId?refId:this.settingsDisabled &&this.refIds&&this.refIds.length&&this.refIds.slice(-1).pop()
            let source = refId&&state.charts[refId]&&state.charts[refId].refrenceSrc
            source = source?source:state.data[this.parentId].source
            return source
            // return state.data[this.parentId].source
          }
        },
        stacked:{
          type:Boolean,
          statePath(state){
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            let objAssignChk = (chartPath && chartPath.settings)
            let stacked = objAssignChk&&chartPath.settings.stacked.value
            return stacked
            // let compStacked = this.settingsDisabled&&this.compChartObjs && this.compChartObjs.stacked
            // return compStacked?compStacked:stacked
          },
          observer:"changedStackedAndGroup"
        },
        group:{
          type:Boolean,
          statePath(state){
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            let objAssignChk = (chartPath && chartPath.settings)
            let group = objAssignChk&&chartPath.settings.group.value
            return group
            // let compGroup = this.settingsDisabled&&this.compChartObjs && this.compChartObjs.group
            // return compGroup?compGroup:group
          },
          observer:"changedStackedAndGroup"
        },
        compChartUUIDChk:{
          type:Boolean,
          statePath(state){
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            let compChartUUIDChk = chartPath && chartPath.compChartUUIDChk
            return compChartUUIDChk
          }
        },
        filterIdxGbl:{
          type:Number,
          statePath(state){
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            // let filterIdxGblChk = chartPath&&this.settingsDisabled&&this.compChartObjs
            let filterIdxGbl = chartPath&&chartPath.filterIdxGbl
            return filterIdxGbl?filterIdxGbl:0
          }
        },
        refIds:{
          type:Array,
          statePath(state){
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            // let refIdsChk = chartPath&&this.settingsDisabled&&this.compChartObjs
            let refIds =  chartPath && chartPath.refIds
            return refIds?refIds:[]
          }
        },
        filterIdx:{
          type:Number,
          statePath(state){
            let chartIdChk = this.settingsDisabled && this.id!=""&&state.charts[this.id]
            // let compChartChk = this.settingsDisabled&&this.compChartObjs
            let filterIdx = chartIdChk && state.charts[this.id].filterIdx
            return filterIdx>=0?filterIdx:-1
          }
        },
        compfilterChk:{
          type:Boolean,
          statePath(state){
            // let chartIdChk = this.settingsDisabled && this.id!=""&&state.charts[this.id]
            // let compChartChk = this.settingsDisabled&&this.compChartObjs
            // let compfilterChk = chartIdChk && state.charts[this.id].compfilterChk
            let chartId = this.settingsDisabled && this.compUUID!=""
            chartId = chartId?this.compUUID:this.uuid
            let chartPath = state.charts[chartId]
            let compfilterChk = chartPath && chartPath.compfilterChk
            return compfilterChk
          },
          observer:"filterSrcLoad"
        },
        filterTimer:{
          type:Number
        },
        filterKeys:{
          type:Array,
          value:[]
        },
        chartTimer:{
          type:Number
        },
        srcLoadTimer:{
          type:Number
        }
      }
    }
    constructor(){
      super();//baseChart

    }
    static get actions() {
      return {
        updateChart(chartProperies) {
          return {
            type: 'UPDATE_CHART',
            value: chartProperies
          };
        },
        splitAreaChk(layoutAreaChk) {
          return {
            type: 'COMPOSITE_SPLIT_AREA_CHK',
            value: layoutAreaChk
          }
        },
        addRefrenceSrc(addRefrenceSrc) {
          return {
            type: 'ADD_COMP_REFRENCE_SRC',
            value: addRefrenceSrc
          }
        },
        filterIdxGbl(filterIdxGbl) {
          return {
            type: 'ADD_FILTER_IDX_GBL',
            value: filterIdxGbl
          }
        },
        addRefrenceIds(refIds) {
          return {
            type: 'ADD_REFRENCE_IDS_GBL',
            value: refIds
          }
        },
        addfilterIdx(filterIdx) {
          return {
            type: 'ADD_FILTER_IDX',
            value: filterIdx
          }
        },
        compfilterChk(compfilterChk) {
          return {
            type: 'COMP_FILTER_CHK',
            value: compfilterChk
          }
        }
      }
    }
    connectedCallback(){
      super.connectedCallback();
      this.initializeChart();
      let updateChartData
      if(this.settingsDisabled){
        updateChartData = {id:this.uuid,inputs:this.inputs}
      }else{
        updateChartData = {id:this.uuid,settings:this.settings,inputs:this.inputs}
      }
      this.dispatch("updateChart",updateChartData);
    }
    changedStackedAndGroup(){
      if(!this.settingsDisabled){this._chartDraw()}
    }
    filterSrcLoad(){
      if(this.settingsDisabled){
        // return this.refIds.length>0
        // debugger
        clearTimeout(this.srcLoadTimer)
        this.srcLoadTimer = setTimeout(()=>{
          this.refIds.length && this.refIds.indexOf(this.id)==-1 && this._chartDraw()
        })
      }
    }
    _chartDraw(){
      clearTimeout(this.chartTimer)
      this.chartTimer = setTimeout(()=>{
        if(this.inputs && Object.keys(this.inputs).length!=0){
          //chart axis dre set here, the axis key's defined in "chart-input" module
          this.axisKeys.forEach(axis=>{this.set(axis,axis)})
          this.redraw()
        }
      })
    }

    draw(paint){
      //this.debounce(arg,interval)
        this.debouncer(paint,2000)
    }
    debouncer(arg,interval){
        return Polymer.Debouncer.debounce(this.debouncer,
          Polymer.Async.timeOut.after(interval), ()=>arg);
    }

    initializeChart(){

      if(this.settingsDisabled){
        this.set("uuid",this.id)
        this.set("filterKeys",[])
      }else{
      this.set("uuid",this.parentId+'@'+this.tagName);
      }
    }
    // add keys and colors to chartstore as keys
    chartKeys(data,key){
      let color = d3.scale.category20c();
      let legendNodes = this.settings.legend.values.nodes;
      // if(legendNodes.length < 1){
        // check whether key is present else show y axis values as label
        if(key==undefined){
          let axisLabel = this.inputs[this.y].selectedObjs[0].key;
          legendNodes = [{key:axisLabel,color:color(axisLabel)}];
        }else{
          legendNodes = data.map(items=>{return {key:items[key],color:color(items[key])}});
        }
      // }
      this.dispatch({type:'UPDATE_PRIVATE_NODE',value:{id:this.uuid,nodes:legendNodes}});
    }
    // to fill color for svg and legends
    colorFill(item,i){
      return item.chartProp.label.nodes[i] ? item.chartProp.label.nodes[i].color : this.color(i);
    }
    clear(){
      d3.select(this.$.chartContainer).html("");
    }
    // check input contains 2 or more axis.
    // if axis value is less than 2 or empty
    // do not need to compute chart values.
    hasInputs(index){
      let inputCheck = Object.keys(this.inputs).length >= index
      inputCheck && this.clear()
      return inputCheck;
    }
    addToolTip(obj){
      this.attachToolTip(obj.container,obj.segments,obj.selector,d=>{
        return `<span><strong>${d.item||d.data.item}</strong><br/>${d.value||d.data.value}<span>`;
      })
    }

    addLegend(obj){
      setTimeout(()=>{
        // this.chartKeys(obj.node,obj.key);
      })
      this.set('color',d3.scale.category20c());
      obj.container.selectAll(obj.selector)
        .style("fill", (d,i)=>{
          return this.colorFill(obj.obj,i);
        })
        .attr("data-legend",(d,i)=>(d[obj.key] || (d.data && d.data[obj.key]))|| (obj.obj.keys && obj.obj.keys[i]) ||this.inputs[this.y].selectedObjs[0].key)
        .attr("data-legend-color",(d,i)=>{return this.colorFill(obj.obj,i);})

      obj.container.append("g")
          .attr("class","legend")
          .attr("transform","translate("+(obj.obj.chartProp.width*obj.obj.chartProp.label.position.x)/100+","+(obj.obj.chartProp.height*obj.obj.chartProp.label.position.y)/100+")")
          .call(d3.legend);

      // add tooltip if segments are provided
      if(obj.segments){
        this.addToolTip(obj);
      }

    }
    getChartProperties(obj){

      //assign stacked and group value
      let stacked = this.stacked,
          group = this.group
      //"inputCheck" for avoid error from chart
      let axisIndex = stacked||group?3:obj.axisIndex
      if(!this.hasInputs(axisIndex))return false
      let axisYKeyRemoveChk = this.axisKeys.length&&this.axisKeys.indexOf("y")==-1
      let axisXKeyRemoveChk = this.axisKeys.length&&this.axisKeys.indexOf("x")==-1
      if(axisYKeyRemoveChk||axisXKeyRemoveChk)return false

      //axis are mentioned in the chart-input module
      let itemX,itemY,itemZ
      //axis inputs selectedValue assigin
      itemX = this.inputs[this.x].selectedValue[0]
      itemY = this.inputs[this.y].selectedValue[0]
      this.inputs[this.z]&&(itemZ = this.inputs[this.z].selectedValue[0])
      group || stacked && itemZ

      let parseDate = d3.time.format('%Y-%m-%d').parse;
      // let settings = this.settingsDisabled&&this.compChartObjs?this.compChartObjs.compChartSettings:this.settings
      let settings = this.settings
      let width = +settings.width.value,
          height = +settings.height.value,
          margin = {top: settings.margin.value.top, right: settings.margin.value.right, bottom: settings.margin.value.bottom, left: settings.margin.value.left},
          label= settings.legend.values,
          compMargin = {top: 15, right: 0, bottom: 75, left: 0}
      // margin = this.compChartObjs?compMargin:margin
      margin = this.settingsDisabled?compMargin:margin

      margin.xMargin = margin.left + margin.right
      margin.yMargin = margin.top + margin.bottom
      width = parseFloat(width -margin.xMargin)
      height = parseFloat(height - margin.yMargin)

      width = this.chartWidth?this.chartWidth:width
      height = this.chartHeight?this.chartHeight:height
      let axis ={itemX,itemY,itemZ}
      let color = d3.scale.category20();
      return{itemX,itemY,itemZ,parseDate,width,height,margin,label,color,stacked,group,settings,axis}
    }
    compSourcePopulate(itemXYZ,eArg){
      // debugger
      clearTimeout(this.filterTimer)
      let axis
      let eArgChk = (eArg.data||eArg.xKey&&typeof eArg.xKey!="number"||eArg.Genre||eArg.Movie||eArg[0]||eArg.title)
      if(eArgChk){
        //Pie chart - eArg.data.item, Waterfall chart - eArg.xKey, Heat map chart - eArg.Genre
        //Pareto chart - eArg.Movie, Box plot chart - eArg[0], Bullet chart - eArg.title
        let filterKeys =  (eArg.data.item||eArg.xKey||eArg.Genre||eArg.Movie||eArg[0]||eArg.title)
        this.push("filterKeys",filterKeys)
        axis = itemXYZ.itemX
      }else if(eArg.zKey||eArg.name || eArg.item || eArg.key){
        //Radar chart, Scatter plot, Area chart, Bar chart and Grouped bar chart
        this.push("filterKeys",(eArg.zKey||eArg.name || eArg.item || eArg.key))
        axis = itemXYZ.itemZ?itemXYZ.itemZ:itemXYZ.itemX
      }


      this.filterTimer = setTimeout(()=>{
        let filterKeys = this.filterKeys.filter((item, pos)=>this.filterKeys.indexOf(item) == pos)
        let filterSrc = []
        filterKeys.map(filterKey=>filterSrc = filterSrc.concat(this.source.filter(items => items[axis] == filterKey)))
        let propData = {}
        propData.filterSrc = filterSrc
        this.set("filterKeys",[])
        let compfilterChk = !this.compfilterChk
        propData.compfilterChk = compfilterChk
        let refIds = this.refIds
        let filterIdxGbl = this.filterIdxGbl
        let filterIdx = this.filterIdx
        this.refIds.indexOf(this.compUUID)==-1 && refIds.push(this.compUUID)
        if(this.refIds.indexOf(this.uuid)==-1){
          refIds.push(this.uuid)
          filterIdxGbl = filterIdxGbl+1
          filterIdx = filterIdx+filterIdxGbl
        }
        propData.refIds = refIds
        propData.filterIdx = filterIdx
        propData.filterIdxGbl = filterIdxGbl
        this.reduxUpdateSrc(propData)
      },1210)
    }
    reduxUpdateSrc(propData){
      this.dispatch("addfilterIdx", {uuid:this.uuid,filterIdx:propData.filterIdx})
      this.dispatch("addRefrenceSrc", {uuid:this.uuid,refrenceSrc:propData.filterSrc})

      this.dispatch("compfilterChk", {uuid:this.compUUID,compfilterChk:propData.compfilterChk})
      this.dispatch("addRefrenceIds", {uuid:this.compUUID,refIds:propData.refIds})
      this.dispatch("filterIdxGbl", {uuid:this.compUUID,filterIdxGbl:propData.filterIdxGbl})

    }
  }
  customElements.define(baseChart.is,baseChart)

</script>
</dom-module>
