<link href="../behaviors/redux-mixins-behavior.html" rel='import'>
<link href="chart-settings.html" rel='import'>

<dom-module id="base-chart">
<template >
  <h3>[[title]] </h3>
</template>
<script>

  class baseChart extends Polymer.mixinBehaviors(
    [PolymerD3.toolTipBehavior],ReduxMixinBehavior(Polymer.Element)
    ){
    static get is(){ return 'base-chart'}

    static get properties(){
      return{
        redrawChk:{
          type:Boolean
        },
        uuid:{
          type:String
        },
        axisKeys:{
          type:String,
          statePath(state){
            let chartPath = state.charts[this.uuid]
            let keyChk = chartPath && Object.keys(chartPath.inputs).length
            let keys = keyChk && Object.keys(chartPath.inputs)
            return keys
          }
        },
        inputs:{
          type:Array,
          observer:'_chartDraw',
          statePath(state){
            var chartPath = state.charts[this.uuid]
            let keyChk = chartPath && Object.keys(chartPath.inputs).length
            return keyChk ? chartPath.inputs:{}
          },
          readOnly:true
        },
        // groupBy:{
        //   type:String
        // },
        // x:{
        //   type:String
        // },
        // y:{
        //   type:String
        // },
        // z:{
        //   type:String
        // },
        settings:{
          type:Object,
          observer:'_chartDraw',
          statePath(state){
            if(state.charts[this.uuid]){
              return state.charts[this.uuid].settings;
            }else{
              return {
                title:{uitype:'text',txt:"Title",value:""},
                margin:{uitype:'visual',txt:'Margin',value:{left:0,top:0,right:0,bottom:0}},
                legend:{uitype:'popup',txt:"Legend Settings",values:{nodes:[],position:{x:10,y:20}}},
                width:{uitype:'number',txt:"Chart width", value:"960"},
                height:{uitype:'number',txt:"Chart Height", value:"500"}
              }
            }
          }

        },
        externals:{
          type:Array,
          statePath(state){
            return state.externals
          }
        },
        source:{
          type:Array,
          statePath(state){
            return state.source
          }
        }
      }
    }
    static get observers(){
      // return["_chartDraw(inputs)"]
    }

    constructor(){
      super();//baseChart
      this.initializeChart();

    }
    static get actions() {
      return {
        updateChart(chartProperies) {
          return {
            type: 'UPDATE_CHART',
            value: chartProperies
          };
        }
      };
    }
    connectedCallback(){
      super.connectedCallback();
      this.dispatch("updateChart",{id:this.uuid,settings:this.settings,inputs:this.inputs});
    }
    _chartDraw(){
      if(this.inputs && Object.keys(this.inputs).length!=0){
        //chart axis dre set here, the axis key's defined in "chart-input" module
        this.axisKeys.forEach(axis=>{this.set(axis,axis)})
        this.redraw()
      }
    }

    draw(paint){
      //this.debounce(arg,interval)
      this.debouncer(paint,250)
    }
    debouncer(arg,interval){
        return Polymer.Debouncer.debounce(this.debouncer,
          Polymer.Async.timeOut.after(interval), () => {arg});
    }
    getChartData(itemGrp){
        let source = this.source.map(row=>row.map((item,i)=>{
              if(itemGrp.indexOf(this.externals[i]['key'])!=-1){
                return {
                  item:this.externals[i]['key'],
                  value:item
                }
              }
            })
          )
        source = [].concat.apply([],source).filter((items,i)=>{
          return items
        })
        return source
    }
    initializeChart(){
        this.set("uuid",PolymerD3.utilities.getUUID())
    }
    // add keys and colors to chartstore as keys
    chartKeys(obj,data,key){
      let legendNodes = this.settings.legend.values.nodes;
      if(legendNodes.length<1){
        legendNodes = data.map(items=>{return {key:items[key],color:obj.color(items[key])}});
      }
      this.dispatch({type:'UPDATE_PRIVATE_NODE',value:{id:this.uuid,nodes:legendNodes}});
    }
    // to fill color for svg and legends
    colorFill(){
      let items = arguments[0];
      let index = arguments[1];
      return this.label.nodes[index] ? this.label.nodes[index].color : this.color(items[0] || items.value);
    }
  }
  customElements.define(baseChart.is,baseChart)

</script>
</dom-module>
