<link href="../behaviors/redux-mixins-behavior.html" rel='import'>

<dom-module id="base-chart">
<template >
  <h3>[[title]] </h3>
</template>
<script>

  class baseChart extends Polymer.mixinBehaviors(
    [PolymerD3.toolTipBehavior],ReduxMixinBehavior(Polymer.Element)
    ){
    static get is(){ return 'base-chart'}

    static get properties(){
      return{
        redrawChk:{
          type:Boolean
        },
        sufficiantInputs:{
          type:Boolean,
          value:false
        },
        uuid:{
          type:String
        },
        parentId:{
          type:String
        },
        axisKeys:{
          type:String,
          statePath(state){
            let chartPath = state.charts[this.uuid]
            let keyChk = chartPath && Object.keys(chartPath.inputs).length
            let keys = keyChk && Object.keys(chartPath.inputs)
            return keys
          }
        },
        inputs:{
          type:Array,
          observer:'_chartDraw',
          statePath(state){
            var chartPath = state.charts[this.uuid]
            let keyChk = chartPath && Object.keys(chartPath.inputs).length
            return keyChk ? chartPath.inputs:{}
          },
          readOnly:true
        },
        // groupBy:{
        //   type:String
        // },
        // x:{
        //   type:String
        // },
        // y:{
        //   type:String
        // },
        // z:{
        //   type:String
        // },
        settings:{
          type:Object,
          observer:'_chartDraw',
          statePath(state){
            if(state.charts[this.uuid]){
              return state.charts[this.uuid].settings;
            }else{
              return {
                title:{uitype:'text',txt:"Title",value:""},
                margin:{uitype:'visual',txt:'Margin',value:{left:0,top:0,right:0,bottom:0}},
                legend:{uitype:'popup',txt:"Legend Settings",values:{nodes:[],position:{x:85,y:5}}},
                width:{uitype:'number',txt:"Chart width", value:"960"},
                height:{uitype:'number',txt:"Chart Height", value:"500"},
                stacked:{uitype:'boolean',value:false,txt:"Stacked Chart"},
                group:{uitype:'boolean',value:false, txt:"Group Chart"}
              }
            }
          }

        },
        externals:{
          type:Array,
          statePath(state){
            return state.data[this.parentId].externals
          }
        },
        source:{
          type:Array,
          statePath(state){
            return state.data[this.parentId].source
          }
        },
        stacked:{
          type:Boolean,
          statePath(state){
            let chartPath = state.charts[this.uuid]
            let objAssignChk = (chartPath && chartPath.settings)
            return objAssignChk&&chartPath.settings.stacked.value
          }
        },
        group:{
          type:Boolean,
          statePath(state){
            let chartPath = state.charts[this.uuid]
            let objAssignChk = (chartPath && chartPath.settings)
            return objAssignChk&&chartPath.settings.group.value
          }
        }
      }
    }
    static get observers(){
      // return["_chartDraw(inputs)"]
    }

    constructor(){
      super();//baseChart

    }
    static get actions() {
      return {
        updateChart(chartProperies) {
          return {
            type: 'UPDATE_CHART',
            value: chartProperies
          };
        }
      };
    }
    connectedCallback(){
      super.connectedCallback();
      this.initializeChart();
      this.dispatch("updateChart",{id:this.uuid,settings:this.settings,inputs:this.inputs});
    }
    _chartDraw(){
      if(this.inputs && Object.keys(this.inputs).length!=0){
        //chart axis dre set here, the axis key's defined in "chart-input" module
        this.axisKeys.forEach(axis=>{this.set(axis,axis)})
        this.redraw()
      }
    }

    draw(paint){
      //this.debounce(arg,interval)
      //if(this.sufficiantInputs)
        this.debouncer(paint,250)
    }
    debouncer(arg,interval){
      // debugger
        return Polymer.Debouncer.debounce(this.debouncer,
          Polymer.Async.timeOut.after(interval), ()=>arg);
    }

    initializeChart(){
      this.set("uuid",this.parentId+'@'+this.tagName);
    }
    // add keys and colors to chartstore as keys
    chartKeys(data,key){
      let color = d3.scale.category20c();
      let legendNodes = this.settings.legend.values.nodes;
      // if(legendNodes.length < 1){
        // check whether key is present else show y axis values as label
        if(key==undefined){
          let axisLabel = this.inputs[this.y].selectedObjs[0].key;
          legendNodes = [{key:axisLabel,color:color(axisLabel)}];
        }else{
          legendNodes = data.map(items=>{return {key:items[key],color:color(items[key])}});
        }
      // }
      this.dispatch({type:'UPDATE_PRIVATE_NODE',value:{id:this.uuid,nodes:legendNodes}});
    }
    // to fill color for svg and legends
    colorFill(item,i){
      return item.chartProp.label.nodes[i] ? item.chartProp.label.nodes[i].color : this.color(i);
    }
    clear(){
      d3.select(this.$.chartContainer).html("");
    }
    // check input contains 2 or more axis.
    // if axis value is less than 2 or empty
    // do not need to compute chart values.
    hasInputs(index){
      let inputCheck = Object.keys(this.inputs).length >= index
      inputCheck && this.clear()
      return inputCheck;
    }
    addToolTip(obj){
      this.attachToolTip(obj.container,obj.segments,obj.selector,d=>{
        return `<span><strong>${d.item||d.data.item}</strong><br/>${d.value||d.data.value}<span>`;
      })
    }

    addLegend(obj){
      setTimeout(()=>{
        // this.chartKeys(obj.node,obj.key);
      })
      this.set('color',d3.scale.category20c());
      obj.container.selectAll(obj.selector)
        .style("fill", (d,i)=>{
          return this.colorFill(obj.obj,i);
        })
        .attr("data-legend",(d,i)=>(d[obj.key] || (d.data && d.data[obj.key]))|| (obj.obj.keys && obj.obj.keys[i]) ||this.inputs[this.y].selectedObjs[0].key)
        .attr("data-legend-color",(d,i)=>{return this.colorFill(obj.obj,i);})

      obj.container.append("g")
          .attr("class","legend")
          .attr("transform","translate("+(obj.obj.chartProp.width*obj.obj.chartProp.label.position.x)/100+","+(obj.obj.chartProp.height*obj.obj.chartProp.label.position.y)/100+")")
          .call(d3.legend);

      // add tooltip if segments are provided
      if(obj.segments){
        this.addToolTip(obj);
      }

    }
    getChartProperties(obj){
      //"inputCheck" for avoid error from chart
      if(!this.hasInputs(obj.axisIndex))return false
      //axis are mentioned in the chart-input module
      let itemX,itemY,itemZ
      //axis inputs selectedValue assigin
      itemX = this.inputs[this.x].selectedValue[0]
      itemY = this.inputs[this.y].selectedValue[0]
      this.inputs[this.z]&&(itemZ = this.inputs[this.z].selectedValue[0])
      obj.group && itemZ
      obj.stacked && itemZ

      let parseDate = d3.time.format('%Y-%m-%d').parse;
      let width = +this.settings.width.value,
          height = +this.settings.height.value,
          margin = {top: 5, right: 40, bottom: 20, left: 120},
          label= this.settings.legend.values
          //margin = {top: +this.settings.margin.value.top, right: +this.settings.margin.value.right, bottom: +this.settings.margin.value.bottom, left: +this.settings.margin.value.left}
      margin.xMargin = margin.left + margin.right
      margin.yMargin = margin.top + margin.bottom
      width = parseFloat(width -margin.xMargin)
      height = parseFloat(height - margin.yMargin)

      let color = d3.scale.category20();
      return{itemX,itemY,itemZ,parseDate,width,height,margin,label,color}
    }
  }
  customElements.define(baseChart.is,baseChart)

</script>
</dom-module>
