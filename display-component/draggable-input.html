<!--Abstracts drag and drop feature-->
<!-- <link rel="import" href="../bower_components/polymer-sortablejs/polymer-sortablejs.html"> -->
<!-- <link rel="import" href="draggable-element.html"> -->
<!-- <link rel="import" href="../behaviors/draggable-behavior.html"> -->
<dom-module id="draggable-input">
  <template>
    
    <!-- <div uuid = [[getUUID]]></div> -->
    <div class="external-items">
        <template is="dom-repeat" items={{externals}}>
          <div data-item="{{item}}" class$="list-item {{item.type}}">
            {{item.key}}
          </div>
        </template>
    </div>

    <!-- <div class="sortable-wrap master-wrap" id="master-holder">
      <sortable-js id="master">
            <paper-icon-button icon="[[_generateIcon(item.type)]]"></paper-icon-button>
          </div>
        </template>
      </sortable-js>
    </div> -->
    <div class="input-items">
      <template is="dom-repeat" items="{{inputs}}" as="input" index-as="inputIndex">
        <div class="item-holder">
          <h4>[[ input.txt ]]</h4>
          <div class="item-drop">
            Drop Items here
          </div>
        </div>
      </template>
      
    </div>
  </template>
  <script>
    Polymer({
      is: 'draggable-input',
      properties: {
        inputs: {
          value: () => { return [];},
          notify: true,
          type: Array
        },
        externals: {
          value: [],
          notify: true,
          type: Array
        },
        currentDrag: Object,
        group: {
          type: Object,
          value: () => {return {};}
        },
        parentElem: {
          type: Object,
          value: () => {return {};}
        },
        uuid: String
      },

      observers: ['_inputsObserver(inputs)', '_externalsObs(externals)'],

      behaviors: [PolymerD3.draggableBehavior],

      _externalsObs: function(externals) {
        console.log('externals');
        if (externals.length) {
          this._externals = PolymerD3.utilities.clone(externals);
        }
      },

      _inputsObserver: function(inputs) {
        if (inputs.length && inputs.length > 0) {
          this.async(() => {
            var slaves = this.querySelectorAll('.slaves');
            for (var i = 0; i < slaves.length; i++) {
              slaves[i].group = {
                name: this.uuid
              };
              // For manual delete
              slaves[i].addEventListener('itemSpliced', this._fireRem.bind(this));
            }
          });
        }
      },

      getColor: function(type) {
        console.log(type, "asdasdsa");
        if (type.length == 1) {
          switch (type[0]) {
            case 'DATE':
              return 'green-bg';
            case 'NUMBER':
              return 'blue-bg';
            case 'STRING':
              return 'yellow-bg';
          }
        }
      },

      attached: function() {
        this.uuid = PolymerD3.utilities.getUUID();
        this.$.master.sort = false;
        this.$.master.group = {
          name: this.uuid,
          pull: 'clone'
        };
        // SortableJS on clone event is a bit buggy, so, remove is used
        this.$['master-holder'].addEventListener('start', this._handleClone.bind(this));
        this.$.inputWrap.addEventListener('add', this._addWatcher.bind(this));
        this.$.inputWrap.addEventListener('remove', this._remWatcher.bind(this));
      },

      // Duplicate removing logic goes here
      _addWatcher: function(e) {
        var template = e.target.querySelector('template');
        if (template.items.length === e.target.maxSelectable) {
          e.target.group.put = false;
          //Add CSS for styling data attribute
          e.target.dataset.dis = 'disabled';
        }

      },

      _remWatcher: function(e) {
        // var template = e.target.querySelector('template');
        e.target.group.put = true;
        e.target.dataset.dis = '';
      },

      _fireRem: function(e) {
        var sortable = e.currentTarget;
        sortable.fire("remove");
        e.stopPropagation();
      },

      // to bring back icons on cloned items
      _handleClone: function(e) {
        var me = this;
        var btns = e.target.querySelectorAll('paper-icon-button');
        var items = e.target.querySelector('template[is="dom-repeat"]');
        if (!btns || !items) {
          return false;
        }
        items = items.items;
        [].forEach.call(btns, (btn, index) => {
          let icon = 'icons:help-outline';
          if (items[index] && items[index].type) {
            icon = me._generateIcon(items[index].type);
          }
          if (!btn.icon) {
            btn.set('icon', icon);
          }
        });
        // hacky fix:
        // polymer-sortable cannot clone model.item.data from an item in a template-repeat
        // so, keeping a copy of the externals and using it to re-rendering the UI
        this.async(() => {
          this.set('externals', []);
        }, 100);
        this.async(() => {
          this.set('externals', this._externals);
        }, 200);
      }
    });
  </script>
</dom-module>
