<link rel="import" href="../display-component/chart-selector.html">
<link href="../behaviors/redux-mixins-behavior.html" rel='import'>
<dom-module id="chart-holder">
<template>
  <template is="dom-if" if="{{settingsVisible}}">
    <div class="tool-bar">
      <chart-selector
      activate-import="[[activateImport]]"
      charts="[[availableCharts]]"
      selected="{{selectedChart}}" paragraph-id="[[paragraphId]]"
      ></chart-selector>
    </div>
  </template>
  <div class="chartHolder"></div>
</template>
<script>
    /**
    * @polymer
    * @extends HTMLElement
    */
  class chartHolder extends Polymer.mixinBehaviors([],ReduxMixinBehavior(Polymer.Element)) {
    static get is(){return 'chart-holder'}
    static get properties(){
      return{
        availableCharts: {
          type: Array,
          value: function() {
          // This list if used when available charts aren' fed from zeppelin-viewer
          // Callback defined in charts and are called after the chart is initated
          // using PolymerD3.utilities.attachElement
          // examples => @{{this._selectedChanged}}
          // barchart.js@{{initStackedBarChart}}
          if (!this.availableCharts) {
            return [{
              label: 'Table',
              icon: 'chart:table-icon',
              element: 'polymerd3-table',
            },{
              label: 'Bar Chart',
              icon: 'chart:composite-stacked',
              element: 'bar-chart'
            }, {
              label: 'Stacked Bar Chart',
              icon: 'chart:stacked-bar-chart',
              element: 'stacked-bar-chart',
            }, {
              label: 'Grouped Bar Chart',
              icon: 'chart:grouped-bar-chart',
              element: 'grouped-bar-chart',
            }, {
              label: 'Waterfall Chart',
              icon: 'chart:waterfall-chart',
              element: 'waterfall-chart',
            }, {
              label: 'Difference',
              icon: 'chart:difference-chart',
              element: 'difference-chart',
            }, {
              label: 'Pie Chart',
              icon: 'chart:pieChart',
              element: 'pie-chart',
            }, {
              label: 'Heat Map',
              icon: 'chart:heatMap',
              element: 'heat-map',
            }, {
              label: 'Area Chart',
              icon: 'chart:area-chart',
              element: 'area-chart',
            }, {
              label: 'Sankey Chart',
              icon: 'chart:sankey-chart',
              element: 'sankey-chart',
            }, {
              label: 'Radar Chart',
              icon: 'chart:radar-chart',
              element: 'radar-chart',
              // callBack: 'radar'
            }, {
              label: 'Scatter Plot Chart',
              icon: 'chart:scatter-plot',
              element: 'scatter-plot'
            }, {
              label: 'Calendar View Chart',
              icon: 'chart:calendar-chart',
              element: 'calendar-chart'
            }, {
              label: 'Pareto Chart',
              icon: 'chart:pareto-chart',
              element: 'pareto-chart'
            },{
              label: 'Horizontal Chart',
              icon: 'chart:horizontal-bar',
              element: 'horizontal-chart'
            }, {
              label: 'Box plot',
              icon: 'chart:calendar-chart',
              element: 'box-plot'
            }, {
              label: 'Bullet Chart',
              icon: 'chart:bullet-chart',
              element: 'bullet-chart'
            }, {
              label: 'Composite Canvas',
              icon: 'icons:dashboard',
              element: 'composite-canvas'
            }];
          }
        }
      },
      activateImport:{
        type:Boolean,
        value:false
      },
      // Object desctibing selected chart type
      selectedChart: {
        type: Object,
        value: () => { return {};}
      },
      selectedChartObj: {
        type: Object,
        value: () => { return {};}
      },
      // Flag to display settngs components
      settingsVisible: {
        type: Boolean,
        value: false
      },
      // Inputs
      externals: {
        type: Array,
        value: () => { return [];}
      },
      inputs: {
        type:Array,
        notify: true,
        value: () => {return [];}
      },
      // Data
      source: {
        type: Array,
        value: () => {return [];}
      },

      // settings
      settings: {
        type: Array,
        value: () => {return [];}
      },

      // State container
      stateContainer: {
        type: Object,
        value: () => {return {};}
      },
      editMode: {
        type: Boolean,
        value: false
      },
      legendSettingsFlag: {
        type: Boolean,
        value: false
      },
      legendSettings: {
        type: Object,
        value: () => {return {};}
      },
      paragraphId:{
        type:String
      },
      currentNestedObj:{
        type:String,
        statePath(state){
          let chartPath = state.charts[this.uuid]
          let currentNestedObj = chartPath && chartPath.currentNestedObj
          return currentNestedObj
        }
      },
      chartData:{
        type:Object,
        statePath(state){
          let chartPath = state.charts[this.uuid]
          let compositeChartData = chartPath && chartPath.compositeChartData
          return compositeChartData
        }
      },
      layoutAreaChk:{
        type:Boolean,
        statePath(state){
          let chartPath = state.charts[this.uuid]
          let layoutAreaChk = chartPath && chartPath.layoutAreaChk
          return layoutAreaChk
        }
      },
      compChartUUIDChk:{
        type:Boolean,
        statePath(state){
          let chartPath = state.charts[this.uuid]
          let compChartUUIDChk = chartPath && chartPath.compChartUUIDChk
          return compChartUUIDChk?compChartUUIDChk:false
        }
      },
      modelCheck:{
        type:Boolean,
        notify:true
      },
      modelChartHolder:{
        type:Boolean,
        value:false
      },
      isCompsiteChart:{
        type:Boolean
      },
      // compsiteChart:{
      //   type:Boolean,
      //   statePath(state){
      //     let chartPath = state.charts
      //     let compsiteChart = chartPath && chartPath.isCompsiteChart
      //     return compsiteChart
      //   }
      //   //value:false,
      //   // observer:"checkIsCompsiteChart"
      // },
      readOnly:{
        type:Boolean,
        statePath(state){
          let chartPath = state.charts[this.uuid]
          let readOnly = chartPath && chartPath.readOnly
          readOnly&&!this.isCompsiteChart?this.set("isCompsiteChart",readOnly):
            this.modelChartHolder&&this.set("isCompsiteChart",this.modelChartHolder)
          return readOnly
        }
      }
    }
  }

  static get actions() {
    return {
      addUpdateChartData(addUpdateChartData) {
        return {
          type: 'ADD_UPDATE_COMPOSITE_CHART_DATA',
          value: addUpdateChartData
        }
      },
      splitAreaChk(layoutAreaChk) {
        return {
          type: 'COMPOSITE_SPLIT_AREA_CHK',
          value: layoutAreaChk
        }
      },
      currentObjNested(currentObjNested) {
        return {
          type: 'CURRENT_NESTED_OBJ',
          value: currentObjNested
        }
      },
      compChartUUIDChk(compChartUUIDChk) {
        return {
          type: 'COMP_CHART_UUID_CHK',
          value: compChartUUIDChk
        }
      }
    }
  }
  updateObjRedux(){
    if(!this.compChartUUIDChk){
      this.set("compChartUUIDChk",!this.compChartUUIDChk)
      this.dispatch("compChartUUIDChk", {uuid:this.uuid,compChartUUIDChk:this.compChartUUIDChk})
    }
    this.dispatch("addUpdateChartData", {uuid:this.uuid,chartData:this.chartData})
    this.set("layoutAreaChk",!this.layoutAreaChk)
    this.dispatch("splitAreaChk", {uuid:this.uuid,layoutAreaChk:this.layoutAreaChk})
    this.dispatch("currentObjNested", {uuid:this.uuid,currentNestedObj:""})
  }

  constructor(){
    super();
  }
  connectedCallback(){
    super.connectedCallback()
  }
  static get observers(){
    return[
    '_selectedChanged(selectedChart)',
    '_selectedChanged(paragraphId)',
    ]
  }
  checkIsCompsiteChart(){
    if(this.isCompsiteChart){
      this.availableCharts.shift()
      this.availableCharts.pop()
      this.set("availableCharts",this.availableCharts)
    }
  }
  // on selected chart changed
  // is also used to draw first chart
  _selectedChanged(selectedChart) {
    let getparagraphId = this.uuid?this.uuid.split("@")[0]:this.paragraphId
    if(selectedChart && getparagraphId){
      let elem;
      if(!this.modelChartHolder){
        this.$$('.chartHolder').innerHTML = ''
      }else{
        this.$$('.chartHolder')&&this.$$('.chartHolder').remove()
      }
      // let isCompsiteChart = (this.isCompsiteChart)
      // this.set("modelCheck",!this.modelCheck)
      // if(this.uuid && this.currentNestedObj&&this.currentNestedObj!=""){
      //   let isCompsiteChart = this.currentNestedObj+".isCompsiteChart"
      //   let chart = this.currentNestedObj+".chart"
      //   let chartId = this.currentNestedObj+".chartId"
      //   let areaId = this.get(this.currentNestedObj+".id")
      //   let chartElement = this.selectedChart.element
      //   let getChartId = this.uuid+"@_"+chartElement+"_"+areaId
      //   let paragraphId = this.currentNestedObj+".paragraphId"
      //   this.set(isCompsiteChart,this.isCompsiteChart)
      //   this.set(chart,chartElement)
      //   this.set(chartId,getChartId)
      //   this.set(paragraphId,getparagraphId)
      //   this.updateObjRedux()
      // }else{
        elem = PolymerD3.utilities.attachElement.call(
          this,
          selectedChart.element,
          '.chartHolder',
          getparagraphId
          );
          this.selectedChartObj = elem;
          this.selectedChartObj.chartInfo = this.selectedChart;
          // this.selectedChartObj.isCompsiteChart = false
      // }
    }

  }

  showInputSettings() {
    if (this.selectedChartObj) {
      this.selectedChartObj.toggleSettingsVisibility();
    }
  }


  // Bootstraps element as per mode(view/edit)
  // This meathod avoids crazy rwo-way binding side effects
  bootstrapCharts(config) {
    this.set('editMode', true);
  }

  // retrives current state of chart-holder
  // is used to save data back to zeppelin
  getSettings() {
    var selectedChart = this.selectedChart;
    selectedChart.settings = this.selectedChartObj.extractData();
    return {
      selectedChart: selectedChart,
      availableCharts: this.availableCharts
    };
  }

}

window.customElements.define(chartHolder.is,chartHolder)

</script>
</dom-module>
