<script>
  PolymerD3.sizingBehavior = {
    properties: {
        area: {
            type: Array
        }
    },
    observers: ['_areaChanged(settings.area.*)'],

    ready: function() {
        this.area = [
            {
                input: 'height',
                txt: 'Height of the chart',
                uitype: 'Number',
                selectedValue: 500
            }, {
                input: 'width',
                txt: 'Width of the chart',
                uitype: 'Number',
                selectedValue: 960
            }, {
                input: 'marginTop',
                txt: 'Top  margin',
                uitype: 'Number',
                selectedValue: 40
            }, {
                input: 'marginRight',
                txt: 'Right margin',
                uitype: 'Number',
                selectedValue: 10
            }, {
                input: 'marginBottom',
                txt: 'Bottom margin',
                uitype: 'Number',
                selectedValue: 20
            }, {
                input: 'marginLeft',
                txt: 'Left margin',
                uitype: 'Number',
                selectedValue: 50
            }
        ];
    },

    attached: function() {
        var me = this;
        this.makeChartWrap();
        if (!this.svgs) {
            this.svgs = [];
        }
        this.svgs.push(me.svg);
        var margin = me.getMargins();
        this._widthChanged();
        this._heightChanged();
        this.svgs.forEach(function(svg) {
            svg.attr('width', me._getWidth() - (margin.left + margin.right))
                .attr('height', me._getHeight() + (margin.top + margin.bottom))
                .append('g')
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        });
    },

    _areaChanged:function(area){
        var me = this;
        this.debounce('areaRedraw', function() {
            if (area.path === 'settings.area') {
                return false;
            }
            var chartDiv = me.querySelector('#chart');
            var margin = me.getMargins();
            chartDiv.style.height = me._getHeight() + "px";
            chartDiv.style.width = me._getWidth() + "px";
            var g = chartDiv.querySelector('svg > g');
            g.setAttribute('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        }, 1000);
    },
    _getHeight: function() {
        return parseInt(this.area[0]['selectedValue']);
    },
    _getWidth: function() {
        return parseInt(this.area[1]['selectedValue']);
    },
    getMargins: function() {
        return {
            top: parseInt(this.area[2]['selectedValue']),
            right: parseInt(this.area[3]['selectedValue']),
            bottom: parseInt(this.area[4]['selectedValue']),
            left: parseInt(this.area[5]['selectedValue'])
        }
    },
    registerHeightChange: function(scale, invert, scaleType){
        if(!this.heightScales)
            this.heightScales = [];
        this.heightScales.push([scale, invert, scaleType]);
        this._heightChanged();
    },
    registerWidthChange: function(scale, invert, scaleType){
        if(!this.widthScales)
            this.widthScales = [];
        this.widthScales.push([scale, invert, scaleType]);
        this._widthChanged();
    },
    _computeHeight: function(){
        var margin = this.getMargins();
        return this._getHeight() - margin.top - margin.bottom;
    },
    _computeWidth: function(){
        var margin = this.getMargins();
        return this._getWidth() - margin.left - margin.right;
    },
    _heightChanged: function(){
        if(this.heightScales){
            var height = this._computeHeight();
            this.heightScales.forEach(function(aScale){
                switch(aScale[2]){
                case 'time':
                case 'linear':
                    aScale[0].range(aScale[1]?[height,0]:[0,height]);
                    break;
                case 'category':
                    aScale[0].rangeRoundBands(aScale[1]?[height,0]:[0,height]);
                    break;
                }
            });
        }
    },
    _widthChanged: function(){
        if(this.widthScales){
            var width = this._computeWidth();
            this.widthScales.forEach(function(aScale){
                switch(aScale[2]){
                case 'time':
                case 'linear':
                    aScale[0].range(aScale[1]?[0, width]:[width, 0]);
                    break;
                case 'category':
                    aScale[0].rangeRoundBands(aScale[1]?[0, width]:[width, 0]);
                    break;
                }
            });
        }
    }
  }
</script>