<script>
PolymerD3.groupingBehavior = {
    group_by : (indices, xIndex, yIndex, headers, type) => {
        var _stack = (groups) => {
            // Sets key if data isn't grouped
            // @Arun Please verify if there's an easeier solution
            groups.forEach((group, i) => {
                if (!group.key) {
                    group.key = headers[yIndex[i]]
                }
            });
            var stackl = d3.layout.stack()
                .offset("zero")
                .values(function(d) {
                    return d.values;
                })
                .x(function(d) {
                    return d[0];
                })
                .y(function(d) {
                    return d[1];
                });
            return stackl(groups);
        };
        var _group_by_col = () => {
            var group = [];
            var map = d3.map();
            var datumIndex = indices[0];
            return {
                process: (aRow) => {
                    var groupName = headers[datumIndex];
                    var aGroup = map.get(groupName);
                    if (!aGroup) {
                        aGroup = {
                            key: groupName,
                            values: [],
                            fill: ''
                        };
                        group.push(aGroup);
                        map.set(groupName, aGroup);
                    }
                    aGroup.values.push([aRow[xIndex], aRow[yIndex]]);
                },
                getGroups: () => {
                    return group;
                },
                getStack: () =>{return _stack(group);}
            };
        };
        var _group_by_cols = () => {
            var groups = [];
            var map = d3.map();
            return {
                process: (aRow) => {
                    indices.forEach((i)=>{
                        var groupName = headers[i];
                        var aGroup = map.get(groupName);
                        if(!aGroup){
                            console.log(" no group:" + groupName);
                            aGroup = {
                                key:groupName,
                                values:[],
                                fill: ''
                            };
                            groups.push(aGroup);
                        }
                        aGroup.values.push([aRow[xIndex], aRow[i]]);
                        map.set(groupName, aGroup);
                    });
                },
                getGroups: () => {
                    return groups;
                },
                getStack: () =>{return _stack(groups);}
            };
        };
        var _waterFallStack = () => {
            let group = [];
            let map = d3.map();
            let datumIndex = indices[0];
            let groupName = headers[xIndex];
            let aGroup = map.get(groupName);
            if (!aGroup) {
                aGroup = {
                    key: groupName,
                    values: [],
                    fill: ''
                };
                group.push(aGroup);
                map.set(groupName, aGroup);
            }
            return {
                process: (aRow) => {
                    aGroup.values.push([aRow[xIndex], aRow[yIndex]]);
                },
                getGroups: () => {
                    return group;
                },
                getStack: () => {
                    let _stacked = group[0].values;
                    let _mapped = [];
                    _stacked.forEach((g, index) => {
                        let yAggregate = g[1];
                        let nextY = yAggregate;
                        // skips first, last(total) and negetive
                        if (index && index != _stacked.length - 1) {
                            if (g[1] > 0) {
                                yAggregate = yAggregate + _mapped[index - 1].y;
                                nextY = yAggregate;
                            } else {
                                yAggregate = _mapped[index - 1].y0;
                                nextY = yAggregate + g[1];
                            }
                        }
                        _mapped.push({
                            0: g[0],
                            1: g[1],
                            y: yAggregate,
                            y0: nextY
                        });
                    });
                    group[0].values = _mapped;
                    return group;
                }
            }
        };
        if (!indices) {
            throw new Error('indices argument mandatory');
        }
        if (type == 'waterfall') {
            return _waterFallStack();
        }
        if (indices.length === 1) {
            return _group_by_col();
        }else{
          return _group_by_cols();
        }
    }
};
</script>
