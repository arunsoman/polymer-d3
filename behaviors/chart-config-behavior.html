<link rel="import" href="timeFormater.html">
<link rel="import" href="axis-behavior.html">
<script>
PolymerD3.chartConfigBehavior = {

    // factory that creates computex and computey
    _computeFactory: function(conf, data) {
        var height = conf.height;
        var width = conf.width;
        var stackIndex = conf.stackIndex;

        var xConf = {
            dataIndex: conf.xheader,
            domain: null,
            range: [0, conf.width],
            scale: null,
            axis: null,
            axisType: conf.xaxisType,
            xFormat: conf.xFormat,
            xAlign: conf.xAlign
        };

        var yConf = {
            dataIndex: conf.yheader,
            domain: null,
            range: [conf.height, 0],
            scale: null,
            axis: null,
            axisType: conf.yaxisType,
            yFormat: conf.yFormat,
            yAlign: conf.yAlign
        };

        function temporal(index) {
            var set = d3.set();
            var eng = {
                process: datum => {
                    var dateAsNumber = +datum[index[0]];
                    if(!set.has(dateAsNumber)){
                        set.add(dateAsNumber);
                    }
                },
                getDomain: () => {
                    var dom = d3.extent(set.values());
                    return [new Date(+dom[0]), new Date(+dom[1])];
                }
            };
            return eng;
        }

        function nonOrdinal(index) {
            var min = Number.MAX_VALUE;
            var max = Number.MIN_VALUE;
            var map = d3.map();

            var group = {
                process: datum => {
                    if (max < datum[index[0]]) {
                        max = datum[index[0]];
                    }
                    if (min > datum[index[0]]) {
                        min = datum[index[0]];
                    }
                },
                getDomain: (forceToZero) => {
                    return [min, max];
                }
            };
            var stack ={
                process: (datum) => {
                    var stackKey = datum[stackIndex];
                    var counter = map.get(stackKey);
                    if(!counter){
                        counter = 0;
                    }
                    counter += datum[index[0]];
                    map.set(stackKey, counter);
                },
                getDomain: (forceToZero, isAggregate, conf) => {
                    let dom = d3.extent(map.values());
                    let tmp = map.values(); // collects all data
                    let max = dom[1];

                    // experimental, for supporting -ve vales in domain
                    // let max = Math.max(Math.abs(dom[0]), Math.abs(dom[1]));

                    // multiple stacks present
                    if (conf && conf.dataIndex.length > 1) {
                        data.forEach(d => {
                            var sum = 0;
                            conf.dataIndex.forEach(di => {
                                sum += d[di];
                            });
                            if (sum > max) {
                                max = sum;
                            }
                        });
                    } else if (isAggregate) { // For waterfall chart
                        max = tmp.pop(); // assumes last element is the largest(total), shortcut for waterfall
                        tmp.reduce((a, b) => {
                            let sum = a + b;
                            if (max < sum) {
                                max = sum;
                            }
                            return sum;
                        }, 0);
                    }
                    // forces domain to start from zero
                    if (forceToZero) {
                        let min = 0;
                        if (dom[0] < 0) {
                            min = dom[0]
                        }
                        return [min, max];
                    }
                    return [dom[0], max];
                }
            };
            return(stackIndex === undefined) ? group : stack;
        }

        function findOrdinalFromHeader(index) {
            var myset = null;
            return {
                process: (aRow) => {
                    if (myset === null) {
                        myset = aRow.filter((d, i) => {
                            return index.includes(i);
                        });
                    }
                },
                getDomain: () => {
                    return myset;
                }
            };
        }

        function findOrdinalFromCol(index) {
            var myset = [];
            return {
                process: (aRow) => {
                    try {
                        var aStr = aRow[index[0]].toString();
                    } catch (e) {
                        console.warn(e, aRow);
                    }
                    if(myset.filter((p)=>{
                            return p.toString() === aStr;
                        }).length === 0)
                    {
                        myset.push(aRow[index[0]]);
                    }
                },
                getDomain: () => {
                    return myset;
                }
            };
        };

        var computex;
        var computey;

        if (conf.containsHeader) {
            var header = data.shift();
            let processHeader = (axisType, domainFrom)=>{
                if(axisType === 'ordinal' && domainFrom.length > 1) {
                    var computer = findOrdinalFromHeader(domainFrom);
                    computer.process(header);
                    return computer;
                }
                return undefined;
            };

            computex = processHeader(xConf.axisType, conf.xheader);
            computey = processHeader(yConf.axisType, conf.yheader);
        }

        function findHandler(axisType, header) {
            switch(axisType) {
            case 'ordinal':
                return findOrdinalFromCol(header);
            case 'time':
                return temporal(header);
            default:
                return nonOrdinal(header);
            }
        };
        if (!computex) {
            computex = findHandler(xConf.axisType, conf.xheader);
        }
        if (!computey) {
            computey = findHandler(yConf.axisType, conf.yheader);
        }
        return {
            computex: computex,
            computey: computey
        };
    },

    // process data object and helps calculate doamin of computeObj
    _processDataWorker: function(data, computeObj, rowCallback) {
        data.forEach((aRow, index) => {
            computeObj.computex.process(aRow);
            computeObj.computey.process(aRow);
            if (rowCallback) {
                rowCallback(aRow, index);
            }
        });
    },

    // returns a function that draws an axis
    _createAxis: function(scaleConfig, conf, scaleFactory) {
        console.log(this);
        debugger;
        let scaleMaker = scaleFactory.bind(this) || this._scaleFactory;
        conf.scale = scaleMaker(scaleConfig, conf);
        conf.axis = d3.svg.axis().orient(scaleConfig.align);
        conf.axis.tickFormat(this._formateAxis(scaleConfig));
        conf.axis.scale(conf.scale);
        let drawAxis = () => {
            conf.axisG = this._createAxisGroup(scaleConfig, conf);
            conf.axisG.attr('class',scaleConfig.clz);
            conf.axisG.call(conf.axis);
        }
        return drawAxis;
    },

    // creates a scale from the config
    _scaleFactory: function(scaleConfig, conf) {
        var barPadding = (!scaleConfig.barPadding) ? 0.1 : scaleConfig.barPadding;
        var align = scaleConfig.align;
        if (!align) {
            throw new Error('scaleConfig.align not defined values {v,h}');
        }
        var computeRange=()=>{
            return ((align === 'right') || (align === 'left')) ?
                    [this.chartHeight, 0] : [0, this.chartWidth];
        };
        var scale;
        switch(scaleConfig.scaleType){
        case 'linear':
            scale =  d3.scale.linear().range(computeRange());
            break;
        case 'time':
            scale =  d3.time.scale().range(computeRange());
            break;
        case 'ordinal':
            if (conf.barInnerPadding == null) {
                scale = d3.scale.ordinal().rangeRoundBands(computeRange(), barPadding);
            } else { // for heat map
                scale = d3.scale.ordinal().rangeRoundBands(computeRange(), 0, conf.barInnerPadding);
            }
            break;
        default:
            throw Error('invalid scaleConfig.scaleType');
        }
        try {
            scale.nice();
        } catch (error) {
            //TODO
        }
        if (scaleConfig.domain){
            scale.domain(scaleConfig.domain);
        }
        return scale;
    },

    _createAxisGroup: function(scaleConfig, conf) {
        if (!scaleConfig.align) {
            throw new Error("scaleConfig.align undefined, can't create axisGroup");
        }

        // keeps track of what axis am I drawing
        let _axisAligner;
        if (scaleConfig.clz == 'x-axis') {
            _axisAligner = conf.yAxisConf.scale(0) || height;
        } else {
            _axisAligner = conf.xAxisConf.scale(0) || width;
        }
        var axisG = conf.parentG.append('g');
        axisG.attr('class', scaleConfig.align + ' axis');
        switch (scaleConfig.align) {
        case 'top':
            break;
        case 'left':
            break;
        case 'right':
            axisG.attr('transform', 'translate(' + _axisAligner + ', 0)');
            break;
        case 'bottom':
            axisG.attr('transform', 'translate(0,' + _axisAligner + ')');
            break;
        }
        return axisG;
    },

    _formateAxis: function(scaleConfig) {
        if (!scaleConfig.format) {
            throw new Error('scaleConfig.format undefined values{number, currency, percent, time}');
        }
        if (scaleConfig.format) {
            switch (scaleConfig.format.toLowerCase()) {
            case 'number':
                return (d3.format('.2s'));
            case 'currency':
                return (d3.format('$.2s'));
            case 'percent':
                return (d3.format('.0%'));
            case 'string':
                return (d) => {
                    if (scaleConfig.dataType === 'data') {
                        var dd = new Date(d);
                        return d3.time.format('%d-%b-%y')(dd);
                    } else{
                        return d;
                    }
                };
            case 'time':
                return PolymerD3.timeFormater.formater(scaleConfig.domain);
            }
        }
    },

    _createXAxis: (xConf, chart) => {
        var config = {
            domain: xConf.domain,
            format: xConf.xFormat,
            align: xConf.xAlign,
            clz:'x-axis',
            scaleType: xConf.axisType
        };
        xConf.draw = chart._createAxis(config, xConf, chart._scaleFactory);
        xConf.axisBehavior = PolymerD3.axisBehavior.attach(xConf.axisG);
        if (!chart.settings.axis) {
            chart.settings.axis = {};
        }
        chart.settings.axis.xConf= xConf.axisBehavior;
        return xConf;
    },

    _createYAxis: (yConf, chart) => {
        var config = {
            domain: yConf.domain,
            format: yConf.yFormat,
            align: yConf.yAlign,
            clz:'y-axis',
            scaleType: yConf.axisType
        };
        yConf.draw = chart._createAxis(config, yConf, chart._scaleFactory);
        yConf.axisBehavior = PolymerD3.axisBehavior.attach(yConf.axisG);
        if (!chart.settings.axis) {
            chart.settings.axis = {};
        }
        chart.settings.axis.yConf= yConf.axisBehavior;
        return yConf;
    },

    chartConfig : function (conf, data, rowCallback) {
        // todo:  remove xConf, yConf duplication
        var xConf = {
            dataIndex: conf.xheader,
            domain: null,
            range: [0, conf.width],
            scale: null,
            axis: null,
            axisType: conf.xaxisType,
            xFormat: conf.xFormat,
            xAlign: conf.xAlign
        };

        var yConf = {
            dataIndex: conf.yheader,
            domain: null,
            range: [conf.height, 0],
            scale: null,
            axis: null,
            axisType: conf.yaxisType,
            yFormat: conf.yFormat,
            yAlign: conf.yAlign
        };

        var height = conf.height;
        var width = conf.width;
        var stackIndex = conf.stackIndex;

        let _compute = this._computeFactory(conf, data);

        let computex = _compute.computex;
        let computey = _compute.computey;

        this._processDataWorker(data, _compute, rowCallback);

        xConf.domain = computex.getDomain();
        // to force to zero for waterfall chart
        yConf.domain = computey.getDomain(conf.forcetToZero, conf.isAggregate, yConf);
        if(conf.yOrigin !== undefined){
            yConf.domain[0] = conf.yOrigin;
        }

        // only creates necessary configuration to draw axes
        xConf = this._createXAxis(xConf, this);
        yConf = this._createYAxis(yConf, this);

        // actually drawing axes
        xConf.draw();
        yConf.draw();

        return {
            getXAxisBehavior: xConf.axisBehavior,
            getYAxisBehavior: yConf.axisBehavior,
            getChartHeight: () => {
                return height;
            },
            getChartWidth: () => {
                return width;
            },
            getX: (x) => {
                return xConf.scale(x);
            },
            getY: (y) => {
                if (y < 0) {
                    y = 0;
                }
                return yConf.scale(y);
            },
            setYDomain: (d)=>{
                yConf.scale.domain(d);
                yConf.axisG.call(yConf.axis);
            },
            setXDomain: (d)=>{
                if(conf.xaxisType  === 'ordinal'){
                    xConf.scale.domain().push(d);
                }
                else{
                    xConf.scale.domain(d);
                }
                xConf.axisG.call(xConf.axis);
            },
            getBarHeight: (h) => {
                switch (yConf.axisType) {
                case 'ordinal':
                    return yConf.scale.rangeBand();
                default:
                    if (h < 0) {
                        h = -h;
                    }
                    // to calculate the height from zero
                    // helpful for charts with -x axis
                    return ((yConf.scale(0) - yConf.scale(h)));
                }
            },
            getBarWidth: (w) => {
                switch (xConf.axisType) {
                case 'ordinal':
                    return xConf.scale.rangeBand();
                default:
                    return xConf.scale(w);
                }
            },
            formatX: (d)=>{
                return xConf.axis.tickFormat()(d);
            },
            formatY: (d)=>{
                return yConf.axis.tickFormat()(d);
            },
        };
    }
};
PolymerD3.chartConfigBehaviorWithTime=[
    PolymerD3.chartConfigBehavior,
    PolymerD3.timeFormater,
    PolymerD3.axisBehavior
];
</script>